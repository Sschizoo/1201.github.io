<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>工作中遇到的经典算法问题与解决思路 - 我的博客</title>
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <header>
        <h1 class="slogan">记录思考，分享生活</h1>
    </header>
    
    <main>
        <div class="container">
            <a href="../index.html" class="back-link">← 返回首页</a>
            
            <article class="article-page">
                <div class="article-header">
                    <h1>工作中遇到的经典算法问题与解决思路</h1>
                    <p class="article-date">2025年07月03日</p>
                </div>
                
                <div class="article-content">
                    <p><strong>Date: March 22, 2024</strong></p>
<p>作为一名软件工程师，虽然日常工作中不会直接编写复杂的算法，但算法思维在解决实际问题时却非常重要。今天想分享几个工作中遇到的算法问题和解决思路。</p>
<h2>数据去重与合并问题</h2>
<h3>问题背景</h3>
<p>在一个用户数据整合项目中，我们需要将来自多个系统的用户数据进行合并。这些数据可能存在重复，需要根据特定规则进行去重和合并。</p>
<h3>问题分析</h3>
<pre><code class="language-javascript">// 示例数据
const users = [
  { id: 1, email: 'john@example.com', name: 'John Doe', source: 'system1' },
  { id: 2, email: 'john@example.com', name: 'John', source: 'system2' },
  { id: 3, email: 'jane@example.com', name: 'Jane Smith', source: 'system1' },
  { id: 4, email: 'jane@example.com', name: 'Jane S.', source: 'system3' },
  { id: 5, email: 'bob@example.com', name: 'Bob Wilson', source: 'system2' }
];
</code></pre>
<p>需要解决的问题：<br />
1. 根据email识别重复用户<br />
2. 合并重复用户的信息<br />
3. 保持数据的完整性和一致性</p>
<h3>解决方案</h3>
<pre><code class="language-javascript">class UserMerger {
  constructor(priorityRules = {}) {
    this.priorityRules = priorityRules;
  }

  // 主要合并函数
  mergeUsers(users) {
    const emailGroups = this.groupByEmail(users);
    const mergedUsers = [];

    for (const [email, userGroup] of emailGroups) {
      if (userGroup.length === 1) {
        mergedUsers.push(userGroup[0]);
      } else {
        const merged = this.mergeUserGroup(userGroup);
        mergedUsers.push(merged);
      }
    }

    return mergedUsers;
  }

  // 按邮箱分组
  groupByEmail(users) {
    const groups = new Map();

    users.forEach(user =&gt; {
      if (!groups.has(user.email)) {
        groups.set(user.email, []);
      }
      groups.get(user.email).push(user);
    });

    return groups;
  }

  // 合并同一组用户
  mergeUserGroup(userGroup) {
    if (userGroup.length === 0) return null;
    if (userGroup.length === 1) return userGroup[0];

    // 按系统优先级排序
    const sortedUsers = this.sortByPriority(userGroup);
    const baseUser = sortedUsers[0];
    const result = { ...baseUser };

    // 合并其他用户的信息
    for (let i = 1; i &lt; sortedUsers.length; i++) {
      result = this.mergeUserData(result, sortedUsers[i]);
    }

    // 记录合并的源
    result.mergedFrom = sortedUsers.map(u =&gt; ({ id: u.id, source: u.source }));

    return result;
  }

  // 按优先级排序
  sortByPriority(users) {
    return users.sort((a, b) =&gt; {
      const priorityA = this.getSourcePriority(a.source);
      const priorityB = this.getSourcePriority(b.source);
      return priorityB - priorityA; // 高优先级在前
    });
  }

  // 获取数据源优先级
  getSourcePriority(source) {
    const defaultPriority = {
      'system1': 3,
      'system2': 2,
      'system3': 1
    };

    return this.priorityRules[source] || defaultPriority[source] || 0;
  }

  // 合并两个用户数据
  mergeUserData(user1, user2) {
    const merged = { ...user1 };

    // 字段合并规则
    const mergeRules = {
      name: (a, b) =&gt; this.chooseBetterString(a, b),
      phone: (a, b) =&gt; a || b,
      address: (a, b) =&gt; a || b,
      lastLoginAt: (a, b) =&gt; this.chooseLatestDate(a, b)
    };

    Object.keys(user2).forEach(key =&gt; {
      if (key === 'id' || key === 'email') return; // 保持主用户的ID和邮箱

      if (mergeRules[key]) {
        merged[key] = mergeRules[key](merged[key], user2[key]);
      } else if (!merged[key] &amp;&amp; user2[key]) {
        merged[key] = user2[key];
      }
    });

    return merged;
  }

  // 选择更好的字符串（更完整的）
  chooseBetterString(str1, str2) {
    if (!str1) return str2;
    if (!str2) return str1;

    // 优先选择更长、更完整的字符串
    if (str1.length &gt; str2.length) return str1;
    if (str2.length &gt; str1.length) return str2;

    // 长度相同时，选择包含更多信息的
    if (str1.split(' ').length &gt; str2.split(' ').length) return str1;

    return str1; // 默认返回第一个
  }

  // 选择最新的日期
  chooseLatestDate(date1, date2) {
    if (!date1) return date2;
    if (!date2) return date1;

    return new Date(date1) &gt; new Date(date2) ? date1 : date2;
  }
}

// 使用示例
const merger = new UserMerger();
const mergedUsers = merger.mergeUsers(users);
console.log('Merged users:', mergedUsers);
</code></pre>
<h2>任务调度与依赖解析</h2>
<h3>问题背景</h3>
<p>在一个数据处理系统中，我们有多个任务需要执行，这些任务之间存在依赖关系。需要设计一个调度器来确保任务按正确的顺序执行。</p>
<h3>解决方案：拓扑排序</h3>
<pre><code class="language-javascript">class TaskScheduler {
  constructor() {
    this.tasks = new Map();
    this.dependencies = new Map();
  }

  // 添加任务
  addTask(taskId, taskFn, dependencies = []) {
    this.tasks.set(taskId, taskFn);
    this.dependencies.set(taskId, dependencies);
  }

  // 拓扑排序获取执行顺序
  getExecutionOrder() {
    const inDegree = new Map();
    const adjList = new Map();

    // 初始化
    for (const taskId of this.tasks.keys()) {
      inDegree.set(taskId, 0);
      adjList.set(taskId, []);
    }

    // 构建邻接表和入度统计
    for (const [taskId, deps] of this.dependencies) {
      for (const dep of deps) {
        if (!this.tasks.has(dep)) {
          throw new Error(`Dependency ${dep} not found for task ${taskId}`);
        }

        adjList.get(dep).push(taskId);
        inDegree.set(taskId, inDegree.get(taskId) + 1);
      }
    }

    // Kahn算法进行拓扑排序
    const queue = [];
    const result = [];

    // 找到所有入度为0的节点
    for (const [taskId, degree] of inDegree) {
      if (degree === 0) {
        queue.push(taskId);
      }
    }

    while (queue.length &gt; 0) {
      const current = queue.shift();
      result.push(current);

      // 移除当前节点的所有出边
      for (const neighbor of adjList.get(current)) {
        inDegree.set(neighbor, inDegree.get(neighbor) - 1);
        if (inDegree.get(neighbor) === 0) {
          queue.push(neighbor);
        }
      }
    }

    // 检查是否存在循环依赖
    if (result.length !== this.tasks.size) {
      throw new Error('Circular dependency detected');
    }

    return result;
  }

  // 执行所有任务
  async executeAll() {
    const executionOrder = this.getExecutionOrder();
    const results = new Map();

    console.log('Execution order:', executionOrder);

    for (const taskId of executionOrder) {
      console.log(`Executing task: ${taskId}`);

      try {
        const taskFn = this.tasks.get(taskId);
        const dependencies = this.dependencies.get(taskId);

        // 收集依赖任务的结果
        const depResults = {};
        for (const dep of dependencies) {
          depResults[dep] = results.get(dep);
        }

        // 执行任务
        const result = await taskFn(depResults);
        results.set(taskId, result);

        console.log(`Task ${taskId} completed`);
      } catch (error) {
        console.error(`Task ${taskId} failed:`, error);
        throw new Error(`Task execution failed: ${taskId}`);
      }
    }

    return results;
  }

  // 获取任务依赖图
  getDependencyGraph() {
    const graph = {};

    for (const [taskId, deps] of this.dependencies) {
      graph[taskId] = deps;
    }

    return graph;
  }
}

// 使用示例
const scheduler = new TaskScheduler();

// 定义任务
scheduler.addTask('fetchUserData', async () =&gt; {
  console.log('Fetching user data...');
  await new Promise(resolve =&gt; setTimeout(resolve, 1000));
  return { users: ['user1', 'user2', 'user3'] };
});

scheduler.addTask('fetchProductData', async () =&gt; {
  console.log('Fetching product data...');
  await new Promise(resolve =&gt; setTimeout(resolve, 800));
  return { products: ['product1', 'product2'] };
});

scheduler.addTask('processUserData', async (deps) =&gt; {
  console.log('Processing user data...');
  const users = deps.fetchUserData.users;
  await new Promise(resolve =&gt; setTimeout(resolve, 500));
  return { processedUsers: users.map(u =&gt; u.toUpperCase()) };
}, ['fetchUserData']);

scheduler.addTask('generateReport', async (deps) =&gt; {
  console.log('Generating report...');
  const users = deps.processUserData.processedUsers;
  const products = deps.fetchProductData.products;
  await new Promise(resolve =&gt; setTimeout(resolve, 300));
  return { report: `Report with ${users.length} users and ${products.length} products` };
}, ['processUserData', 'fetchProductData']);

// 执行
scheduler.executeAll()
  .then(results =&gt; {
    console.log('All tasks completed:', results);
  })
  .catch(error =&gt; {
    console.error('Execution failed:', error);
  });
</code></pre>
<h2>缓存LRU算法实现</h2>
<h3>问题背景</h3>
<p>在一个API网关项目中，需要实现一个高效的缓存系统，要求能够自动淘汰最近最少使用的数据。</p>
<h3>解决方案</h3>
<pre><code class="language-javascript">class LRUCache {
  constructor(capacity) {
    this.capacity = capacity;
    this.cache = new Map();
  }

  get(key) {
    if (this.cache.has(key)) {
      // 重新插入以更新位置（Map的插入顺序）
      const value = this.cache.get(key);
      this.cache.delete(key);
      this.cache.set(key, value);
      return value;
    }
    return null;
  }

  put(key, value) {
    if (this.cache.has(key)) {
      // 更新现有key
      this.cache.delete(key);
    } else if (this.cache.size &gt;= this.capacity) {
      // 删除最老的项（第一个）
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }

    this.cache.set(key, value);
  }

  // 获取缓存统计信息
  getStats() {
    return {
      size: this.cache.size,
      capacity: this.capacity,
      keys: Array.from(this.cache.keys())
    };
  }

  // 清空缓存
  clear() {
    this.cache.clear();
  }
}

// 增强版LRU缓存，支持TTL
class TTLLRUCache extends LRUCache {
  constructor(capacity, defaultTTL = 300000) { // 默认5分钟
    super(capacity);
    this.defaultTTL = defaultTTL;
    this.timers = new Map();
  }

  put(key, value, ttl = this.defaultTTL) {
    // 清除旧的定时器
    if (this.timers.has(key)) {
      clearTimeout(this.timers.get(key));
    }

    super.put(key, value);

    // 设置新的定时器
    const timer = setTimeout(() =&gt; {
      this.cache.delete(key);
      this.timers.delete(key);
    }, ttl);

    this.timers.set(key, timer);
  }

  get(key) {
    if (!this.cache.has(key)) {
      return null;
    }

    // 检查是否过期（双重保险）
    if (!this.timers.has(key)) {
      this.cache.delete(key);
      return null;
    }

    return super.get(key);
  }

  clear() {
    // 清除所有定时器
    for (const timer of this.timers.values()) {
      clearTimeout(timer);
    }
    this.timers.clear();
    super.clear();
  }
}

// 使用示例
const cache = new TTLLRUCache(3, 5000); // 容量3，TTL 5秒

cache.put('user:1', { name: 'John', age: 30 });
cache.put('user:2', { name: 'Jane', age: 25 });
cache.put('user:3', { name: 'Bob', age: 35 });

console.log(cache.get('user:1')); // { name: 'John', age: 30 }
console.log(cache.getStats()); // { size: 3, capacity: 3, keys: ['user:2', 'user:3', 'user:1'] }

cache.put('user:4', { name: 'Alice', age: 28 }); // user:2 被淘汰
console.log(cache.getStats()); // { size: 3, capacity: 3, keys: ['user:3', 'user:1', 'user:4'] }
</code></pre>
<h2>滑动窗口算法应用</h2>
<h3>问题背景</h3>
<p>在一个监控系统中，需要计算API请求的滑动窗口统计信息，如QPS、响应时间等。</p>
<h3>解决方案</h3>
<pre><code class="language-javascript">class SlidingWindowStats {
  constructor(windowSizeMs = 60000) { // 默认1分钟窗口
    this.windowSize = windowSizeMs;
    this.requests = [];
    this.responseTime = [];
  }

  // 记录请求
  recordRequest(timestamp = Date.now(), responseTimeMs = 0) {
    this.requests.push(timestamp);
    this.responseTime.push(responseTimeMs);
    this.cleanup(timestamp);
  }

  // 清理过期数据
  cleanup(currentTime) {
    const cutoff = currentTime - this.windowSize;

    while (this.requests.length &gt; 0 &amp;&amp; this.requests[0] &lt; cutoff) {
      this.requests.shift();
      this.responseTime.shift();
    }
  }

  // 获取QPS
  getQPS(timestamp = Date.now()) {
    this.cleanup(timestamp);
    return this.requests.length / (this.windowSize / 1000);
  }

  // 获取平均响应时间
  getAverageResponseTime(timestamp = Date.now()) {
    this.cleanup(timestamp);

    if (this.responseTime.length === 0) return 0;

    const sum = this.responseTime.reduce((a, b) =&gt; a + b, 0);
    return sum / this.responseTime.length;
  }

  // 获取响应时间百分位
  getResponseTimePercentile(percentile, timestamp = Date.now()) {
    this.cleanup(timestamp);

    if (this.responseTime.length === 0) return 0;

    const sorted = [...this.responseTime].sort((a, b) =&gt; a - b);
    const index = Math.ceil((percentile / 100) * sorted.length) - 1;
    return sorted[Math.max(0, index)];
  }

  // 获取完整统计信息
  getStats(timestamp = Date.now()) {
    this.cleanup(timestamp);

    return {
      totalRequests: this.requests.length,
      qps: this.getQPS(timestamp),
      avgResponseTime: this.getAverageResponseTime(timestamp),
      p50: this.getResponseTimePercentile(50, timestamp),
      p90: this.getResponseTimePercentile(90, timestamp),
      p99: this.getResponseTimePercentile(99, timestamp),
      windowSizeMs: this.windowSize
    };
  }
}

// 使用示例
const stats = new SlidingWindowStats(60000); // 60秒窗口

// 模拟请求
const now = Date.now();
for (let i = 0; i &lt; 100; i++) {
  const timestamp = now - Math.random() * 50000; // 过去50秒内的随机时间
  const responseTime = Math.random() * 200 + 50; // 50-250ms的响应时间
  stats.recordRequest(timestamp, responseTime);
}

console.log('API Stats:', stats.getStats());
</code></pre>
<h2>分布式ID生成算法</h2>
<h3>问题背景</h3>
<p>在微服务架构中，需要生成全局唯一的ID，要求高性能、有序性、避免冲突。</p>
<h3>解决方案：Snowflake算法</h3>
<pre><code class="language-javascript">class SnowflakeIdGenerator {
  constructor(datacenterId = 1, workerId = 1) {
    // 各部分位数
    this.sequenceBits = 12;
    this.workerIdBits = 5;
    this.datacenterIdBits = 5;

    // 最大值
    this.maxSequence = (1 &lt;&lt; this.sequenceBits) - 1;
    this.maxWorkerId = (1 &lt;&lt; this.workerIdBits) - 1;
    this.maxDatacenterId = (1 &lt;&lt; this.datacenterIdBits) - 1;

    // 位移量
    this.workerIdShift = this.sequenceBits;
    this.datacenterIdShift = this.sequenceBits + this.workerIdBits;
    this.timestampShift = this.sequenceBits + this.workerIdBits + this.datacenterIdBits;

    // 参数验证
    if (workerId &gt; this.maxWorkerId || workerId &lt; 0) {
      throw new Error(`Worker ID must be between 0 and ${this.maxWorkerId}`);
    }
    if (datacenterId &gt; this.maxDatacenterId || datacenterId &lt; 0) {
      throw new Error(`Datacenter ID must be between 0 and ${this.maxDatacenterId}`);
    }

    this.workerId = workerId;
    this.datacenterId = datacenterId;
    this.sequence = 0;
    this.lastTimestamp = 0;

    // 基准时间戳 (2020-01-01)
    this.epoch = 1577836800000;
  }

  nextId() {
    let timestamp = Date.now();

    // 时钟回退检查
    if (timestamp &lt; this.lastTimestamp) {
      throw new Error(`Clock moved backwards. Refusing to generate id for ${this.lastTimestamp - timestamp} milliseconds`);
    }

    if (timestamp === this.lastTimestamp) {
      // 同一毫秒内，序列号递增
      this.sequence = (this.sequence + 1) &amp; this.maxSequence;

      if (this.sequence === 0) {
        // 序列号溢出，等待下一毫秒
        timestamp = this.waitNextMillis(this.lastTimestamp);
      }
    } else {
      // 新的毫秒，序列号重置
      this.sequence = 0;
    }

    this.lastTimestamp = timestamp;

    // 生成ID
    const timestampPart = (timestamp - this.epoch) &lt;&lt; this.timestampShift;
    const datacenterPart = this.datacenterId &lt;&lt; this.datacenterIdShift;
    const workerPart = this.workerId &lt;&lt; this.workerIdShift;

    return timestampPart | datacenterPart | workerPart | this.sequence;
  }

  waitNextMillis(lastTimestamp) {
    let timestamp = Date.now();
    while (timestamp &lt;= lastTimestamp) {
      timestamp = Date.now();
    }
    return timestamp;
  }

  // 解析ID的各个部分
  parseId(id) {
    const timestamp = (id &gt;&gt; this.timestampShift) + this.epoch;
    const datacenterId = (id &gt;&gt; this.datacenterIdShift) &amp; this.maxDatacenterId;
    const workerId = (id &gt;&gt; this.workerIdShift) &amp; this.maxWorkerId;
    const sequence = id &amp; this.maxSequence;

    return {
      timestamp: new Date(timestamp),
      datacenterId,
      workerId,
      sequence,
      id
    };
  }
}

// 使用示例
const idGenerator = new SnowflakeIdGenerator(1, 1);

// 生成ID
const ids = [];
for (let i = 0; i &lt; 10; i++) {
  const id = idGenerator.nextId();
  ids.push(id);
  console.log(`Generated ID: ${id}`);
}

// 解析ID
console.log('\nParsed IDs:');
ids.forEach(id =&gt; {
  console.log(idGenerator.parseId(id));
});
</code></pre>
<h2>总结与思考</h2>
<p>通过这些实际工作中的算法应用，我有几点体会：</p>
<h3>1. 算法思维的重要性</h3>
<p>虽然不需要实现复杂的算法，但算法思维能帮助我们：<br />
- 更好地分析问题的复杂度<br />
- 选择合适的数据结构<br />
- 优化系统性能<br />
- 设计可扩展的解决方案</p>
<h3>2. 实际应用的考虑因素</h3>
<p>在实际应用中，除了算法本身，还需要考虑：<br />
- 错误处理和边界情况<br />
- 内存和时间复杂度<br />
- 可维护性和可读性<br />
- 并发安全性</p>
<h3>3. 持续学习的必要性</h3>
<p>算法知识需要在实践中不断深化：<br />
- 理论学习与实际应用相结合<br />
- 关注性能优化和最佳实践<br />
- 学习业界成熟的解决方案<br />
- 保持对新算法和数据结构的敏感度</p>
<p>这些算法问题的解决过程让我更深刻地理解了算法在实际工程中的价值。它们不仅仅是面试题，更是解决实际问题的有力工具。</p>
                </div>
            </article>
        </div>
    </main>
    
    <footer>
        <p>&copy; 2025 我的博客. All rights reserved.</p>
    </footer>
</body>
</html>