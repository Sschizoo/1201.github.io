<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GraphQL API设计与性能优化实战 - 我的博客</title>
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <header>
        <h1 class="slogan">记录思考，分享生活</h1>
    </header>
    
    <main>
        <div class="container">
            <a href="../index.html" class="back-link">← 返回首页</a>
            
            <article class="article-page">
                <div class="article-header">
                    <h1>GraphQL API设计与性能优化实战</h1>
                    <p class="article-date">2025年07月03日</p>
                </div>
                
                <div class="article-content">
                    <p><strong>Date: May 3, 2024</strong></p>
<p>随着前端应用复杂度的增加，传统的REST API开始暴露出一些限制。GraphQL作为一种新的API查询语言，为我们提供了更灵活的数据获取方式。今天分享一下我在GraphQL API设计和性能优化方面的实践经验。</p>
<h2>GraphQL基础架构搭建</h2>
<h3>基础Schema设计</h3>
<pre><code class="language-javascript">const { GraphQLSchema, GraphQLObjectType, GraphQLString, GraphQLInt, GraphQLList, GraphQLNonNull } = require('graphql');

// 用户类型定义
const UserType = new GraphQLObjectType({
  name: 'User',
  description: 'A user in our application',
  fields: () =&gt; ({
    id: {
      type: GraphQLNonNull(GraphQLString),
      description: 'The unique identifier for the user'
    },
    name: {
      type: GraphQLNonNull(GraphQLString),
      description: 'The user\'s full name'
    },
    email: {
      type: GraphQLNonNull(GraphQLString),
      description: 'The user\'s email address'
    },
    posts: {
      type: GraphQLList(PostType),
      description: 'Posts created by this user',
      resolve: async (user, args, context) =&gt; {
        return await context.dataSources.postAPI.getPostsByUserId(user.id);
      }
    },
    followers: {
      type: GraphQLList(UserType),
      description: 'Users following this user',
      resolve: async (user, args, context) =&gt; {
        return await context.dataSources.userAPI.getFollowers(user.id);
      }
    },
    followersCount: {
      type: GraphQLInt,
      description: 'Number of followers',
      resolve: async (user, args, context) =&gt; {
        // 优化：只返回数量，不查询完整用户信息
        return await context.dataSources.userAPI.getFollowersCount(user.id);
      }
    }
  })
});

// 文章类型定义
const PostType = new GraphQLObjectType({
  name: 'Post',
  description: 'A blog post',
  fields: () =&gt; ({
    id: {
      type: GraphQLNonNull(GraphQLString),
      description: 'The unique identifier for the post'
    },
    title: {
      type: GraphQLNonNull(GraphQLString),
      description: 'The post title'
    },
    content: {
      type: GraphQLString,
      description: 'The post content'
    },
    author: {
      type: UserType,
      description: 'The author of this post',
      resolve: async (post, args, context) =&gt; {
        return await context.dataSources.userAPI.getUserById(post.authorId);
      }
    },
    comments: {
      type: GraphQLList(CommentType),
      description: 'Comments on this post',
      args: {
        limit: { type: GraphQLInt, defaultValue: 10 },
        offset: { type: GraphQLInt, defaultValue: 0 }
      },
      resolve: async (post, args, context) =&gt; {
        return await context.dataSources.commentAPI.getCommentsByPostId(
          post.id, 
          args.limit, 
          args.offset
        );
      }
    },
    createdAt: {
      type: GraphQLString,
      description: 'When the post was created'
    }
  })
});

// 评论类型定义
const CommentType = new GraphQLObjectType({
  name: 'Comment',
  description: 'A comment on a post',
  fields: () =&gt; ({
    id: {
      type: GraphQLNonNull(GraphQLString)
    },
    content: {
      type: GraphQLNonNull(GraphQLString)
    },
    author: {
      type: UserType,
      resolve: async (comment, args, context) =&gt; {
        return await context.dataSources.userAPI.getUserById(comment.authorId);
      }
    },
    post: {
      type: PostType,
      resolve: async (comment, args, context) =&gt; {
        return await context.dataSources.postAPI.getPostById(comment.postId);
      }
    },
    createdAt: {
      type: GraphQLString
    }
  })
});
</code></pre>
<h3>查询和变更定义</h3>
<pre><code class="language-javascript">const { GraphQLInputObjectType } = require('graphql');

// 输入类型定义
const CreateUserInput = new GraphQLInputObjectType({
  name: 'CreateUserInput',
  fields: {
    name: { type: GraphQLNonNull(GraphQLString) },
    email: { type: GraphQLNonNull(GraphQLString) },
    password: { type: GraphQLNonNull(GraphQLString) }
  }
});

const CreatePostInput = new GraphQLInputObjectType({
  name: 'CreatePostInput',
  fields: {
    title: { type: GraphQLNonNull(GraphQLString) },
    content: { type: GraphQLString },
    authorId: { type: GraphQLNonNull(GraphQLString) }
  }
});

// 查询根类型
const RootQuery = new GraphQLObjectType({
  name: 'RootQueryType',
  description: 'The root query type',
  fields: {
    user: {
      type: UserType,
      description: 'Get a single user by ID',
      args: {
        id: { type: GraphQLNonNull(GraphQLString) }
      },
      resolve: async (parent, args, context) =&gt; {
        return await context.dataSources.userAPI.getUserById(args.id);
      }
    },
    users: {
      type: GraphQLList(UserType),
      description: 'Get a list of users',
      args: {
        limit: { type: GraphQLInt, defaultValue: 10 },
        offset: { type: GraphQLInt, defaultValue: 0 },
        search: { type: GraphQLString }
      },
      resolve: async (parent, args, context) =&gt; {
        return await context.dataSources.userAPI.getUsers(args);
      }
    },
    post: {
      type: PostType,
      description: 'Get a single post by ID',
      args: {
        id: { type: GraphQLNonNull(GraphQLString) }
      },
      resolve: async (parent, args, context) =&gt; {
        return await context.dataSources.postAPI.getPostById(args.id);
      }
    },
    posts: {
      type: GraphQLList(PostType),
      description: 'Get a list of posts',
      args: {
        limit: { type: GraphQLInt, defaultValue: 10 },
        offset: { type: GraphQLInt, defaultValue: 0 },
        authorId: { type: GraphQLString }
      },
      resolve: async (parent, args, context) =&gt; {
        if (args.authorId) {
          return await context.dataSources.postAPI.getPostsByUserId(args.authorId);
        }
        return await context.dataSources.postAPI.getPosts(args);
      }
    }
  }
});

// 变更根类型
const RootMutation = new GraphQLObjectType({
  name: 'RootMutationType',
  description: 'The root mutation type',
  fields: {
    createUser: {
      type: UserType,
      description: 'Create a new user',
      args: {
        input: { type: GraphQLNonNull(CreateUserInput) }
      },
      resolve: async (parent, args, context) =&gt; {
        return await context.dataSources.userAPI.createUser(args.input);
      }
    },
    createPost: {
      type: PostType,
      description: 'Create a new post',
      args: {
        input: { type: GraphQLNonNull(CreatePostInput) }
      },
      resolve: async (parent, args, context) =&gt; {
        return await context.dataSources.postAPI.createPost(args.input);
      }
    },
    updatePost: {
      type: PostType,
      description: 'Update an existing post',
      args: {
        id: { type: GraphQLNonNull(GraphQLString) },
        input: { type: CreatePostInput }
      },
      resolve: async (parent, args, context) =&gt; {
        return await context.dataSources.postAPI.updatePost(args.id, args.input);
      }
    },
    deletePost: {
      type: GraphQLString,
      description: 'Delete a post',
      args: {
        id: { type: GraphQLNonNull(GraphQLString) }
      },
      resolve: async (parent, args, context) =&gt; {
        await context.dataSources.postAPI.deletePost(args.id);
        return 'Post deleted successfully';
      }
    }
  }
});

// 创建Schema
const schema = new GraphQLSchema({
  query: RootQuery,
  mutation: RootMutation
});
</code></pre>
<h2>数据源层设计</h2>
<h3>RESTful API数据源</h3>
<pre><code class="language-javascript">const { RESTDataSource } = require('apollo-datasource-rest');

class UserAPI extends RESTDataSource {
  constructor() {
    super();
    this.baseURL = 'http://localhost:3001/api/';
  }

  async getUserById(id) {
    const user = await this.get(`users/${id}`);
    return this.userReducer(user);
  }

  async getUsers({ limit, offset, search }) {
    const params = { limit, offset };
    if (search) {
      params.search = search;
    }

    const response = await this.get('users', params);
    return response.users.map(user =&gt; this.userReducer(user));
  }

  async createUser(userData) {
    const response = await this.post('users', userData);
    return this.userReducer(response.user);
  }

  async getFollowers(userId) {
    const response = await this.get(`users/${userId}/followers`);
    return response.followers.map(user =&gt; this.userReducer(user));
  }

  async getFollowersCount(userId) {
    const response = await this.get(`users/${userId}/followers/count`);
    return response.count;
  }

  // 数据转换器，统一数据格式
  userReducer(user) {
    return {
      id: user.id,
      name: user.name,
      email: user.email,
      createdAt: user.created_at,
      // 添加其他必要的字段转换
    };
  }
}

class PostAPI extends RESTDataSource {
  constructor() {
    super();
    this.baseURL = 'http://localhost:3002/api/';
  }

  async getPostById(id) {
    const post = await this.get(`posts/${id}`);
    return this.postReducer(post);
  }

  async getPosts({ limit, offset }) {
    const response = await this.get('posts', { limit, offset });
    return response.posts.map(post =&gt; this.postReducer(post));
  }

  async getPostsByUserId(userId) {
    const response = await this.get(`posts?authorId=${userId}`);
    return response.posts.map(post =&gt; this.postReducer(post));
  }

  async createPost(postData) {
    const response = await this.post('posts', postData);
    return this.postReducer(response.post);
  }

  async updatePost(id, postData) {
    const response = await this.put(`posts/${id}`, postData);
    return this.postReducer(response.post);
  }

  async deletePost(id) {
    await this.delete(`posts/${id}`);
    return true;
  }

  postReducer(post) {
    return {
      id: post.id,
      title: post.title,
      content: post.content,
      authorId: post.author_id,
      createdAt: post.created_at,
      updatedAt: post.updated_at
    };
  }
}
</code></pre>
<h3>数据库数据源</h3>
<pre><code class="language-javascript">const { DataSource } = require('apollo-datasource');

class DatabaseAPI extends DataSource {
  constructor(database) {
    super();
    this.db = database;
  }

  initialize(config) {
    this.context = config.context;
    this.cache = config.cache;
  }

  async getUserById(id) {
    // 尝试从缓存获取
    const cacheKey = `user:${id}`;
    const cached = await this.cache.get(cacheKey);

    if (cached) {
      return JSON.parse(cached);
    }

    // 从数据库查询
    const query = 'SELECT * FROM users WHERE id = ?';
    const result = await this.db.query(query, [id]);

    if (result.length === 0) {
      return null;
    }

    const user = this.userReducer(result[0]);

    // 缓存结果
    await this.cache.set(cacheKey, JSON.stringify(user), { ttl: 300 });

    return user;
  }

  async getUsersByIds(ids) {
    if (ids.length === 0) return [];

    // 批量查询减少数据库访问
    const placeholders = ids.map(() =&gt; '?').join(',');
    const query = `SELECT * FROM users WHERE id IN (${placeholders})`;
    const results = await this.db.query(query, ids);

    return results.map(user =&gt; this.userReducer(user));
  }

  userReducer(user) {
    return {
      id: user.id.toString(),
      name: user.name,
      email: user.email,
      createdAt: user.created_at.toISOString()
    };
  }
}
</code></pre>
<h2>性能优化策略</h2>
<h3>DataLoader解决N+1查询问题</h3>
<pre><code class="language-javascript">const DataLoader = require('dataloader');

class OptimizedUserAPI extends DatabaseAPI {
  constructor(database) {
    super(database);

    // 创建DataLoader实例
    this.userLoader = new DataLoader(async (userIds) =&gt; {
      const users = await this.getUsersByIds(userIds);

      // 确保返回的数组顺序与请求的ID顺序一致
      const userMap = new Map(users.map(user =&gt; [user.id, user]));
      return userIds.map(id =&gt; userMap.get(id) || null);
    });

    this.postsByUserLoader = new DataLoader(async (userIds) =&gt; {
      const posts = await this.getPostsByUserIds(userIds);

      // 按用户ID分组
      const postsByUser = userIds.map(userId =&gt; 
        posts.filter(post =&gt; post.authorId === userId)
      );

      return postsByUser;
    });
  }

  async getUserById(id) {
    return await this.userLoader.load(id);
  }

  async getPostsByUserId(userId) {
    const posts = await this.postsByUserLoader.load(userId);
    return posts;
  }

  async getPostsByUserIds(userIds) {
    if (userIds.length === 0) return [];

    const placeholders = userIds.map(() =&gt; '?').join(',');
    const query = `SELECT * FROM posts WHERE author_id IN (${placeholders}) ORDER BY created_at DESC`;
    const results = await this.db.query(query, userIds);

    return results.map(post =&gt; this.postReducer(post));
  }

  postReducer(post) {
    return {
      id: post.id.toString(),
      title: post.title,
      content: post.content,
      authorId: post.author_id.toString(),
      createdAt: post.created_at.toISOString()
    };
  }
}
</code></pre>
<h3>查询复杂度分析</h3>
<pre><code class="language-javascript">const depthLimit = require('graphql-depth-limit');
const costAnalysis = require('graphql-cost-analysis');

// 查询深度限制
const depthLimitRule = depthLimit(10);

// 查询复杂度分析
const costAnalysisRule = costAnalysis.createRateLimitRule({
  createError: (max, actual) =&gt; {
    return new Error(`Query cost ${actual} exceeds maximum cost ${max}`);
  },
  maximumCost: 1000,
  scalarCost: 1,
  objectCost: 2,
  listFactor: 10,
  introspectionCost: 1000,
  fieldExtension: () =&gt; ({
    cost: ({ type, field, args }) =&gt; {
      // 根据字段类型动态计算成本
      if (field.name === 'posts') {
        const limit = args.limit || 10;
        return limit * 2; // 每个post成本为2
      }

      if (field.name === 'followers') {
        return 50; // 关注者查询成本较高
      }

      return 1; // 默认成本
    }
  })
});

// 应用规则
const validationRules = [
  depthLimitRule,
  costAnalysisRule
];
</code></pre>
<h3>缓存策略</h3>
<pre><code class="language-javascript">const Redis = require('redis');

class CacheManager {
  constructor() {
    this.redis = Redis.createClient();
    this.defaultTTL = 300; // 5分钟
  }

  async get(key) {
    try {
      const data = await this.redis.get(key);
      return data ? JSON.parse(data) : null;
    } catch (error) {
      console.error('Cache get error:', error);
      return null;
    }
  }

  async set(key, value, ttl = this.defaultTTL) {
    try {
      await this.redis.setex(key, ttl, JSON.stringify(value));
    } catch (error) {
      console.error('Cache set error:', error);
    }
  }

  async invalidate(pattern) {
    try {
      const keys = await this.redis.keys(pattern);
      if (keys.length &gt; 0) {
        await this.redis.del(...keys);
      }
    } catch (error) {
      console.error('Cache invalidation error:', error);
    }
  }

  generateKey(prefix, id, fields = []) {
    const fieldHash = fields.sort().join(',');
    return `${prefix}:${id}:${this.hashString(fieldHash)}`;
  }

  hashString(str) {
    let hash = 0;
    for (let i = 0; i &lt; str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash &lt;&lt; 5) - hash) + char;
      hash = hash &amp; hash; // 转换为32位整数
    }
    return Math.abs(hash);
  }
}

// 基于字段的缓存策略
class FieldLevelCache {
  constructor(cacheManager) {
    this.cache = cacheManager;
  }

  async resolveWithCache(type, id, fields, resolver) {
    const cacheKey = this.cache.generateKey(type, id, fields);
    let data = await this.cache.get(cacheKey);

    if (!data) {
      data = await resolver();
      if (data) {
        await this.cache.set(cacheKey, data);
      }
    }

    return data;
  }

  invalidateType(type, id) {
    const pattern = `${type}:${id}:*`;
    return this.cache.invalidate(pattern);
  }
}
</code></pre>
<h3>订阅和实时更新</h3>
<pre><code class="language-javascript">const { PubSub } = require('graphql-subscriptions');
const { GraphQLSubscription } = require('graphql');

const pubsub = new PubSub();

// 订阅类型定义
const RootSubscription = new GraphQLObjectType({
  name: 'RootSubscriptionType',
  fields: {
    postAdded: {
      type: PostType,
      description: 'Subscribe to new posts',
      args: {
        authorId: { type: GraphQLString }
      },
      subscribe: (parent, args) =&gt; {
        const channel = args.authorId ? 
          `POST_ADDED_${args.authorId}` : 
          'POST_ADDED';

        return pubsub.asyncIterator(channel);
      }
    },
    commentAdded: {
      type: CommentType,
      description: 'Subscribe to new comments on a post',
      args: {
        postId: { type: GraphQLNonNull(GraphQLString) }
      },
      subscribe: (parent, args) =&gt; {
        return pubsub.asyncIterator(`COMMENT_ADDED_${args.postId}`);
      }
    }
  }
});

// 在Mutation中发布事件
const createPostWithSubscription = async (parent, args, context) =&gt; {
  const post = await context.dataSources.postAPI.createPost(args.input);

  // 发布事件
  pubsub.publish('POST_ADDED', { postAdded: post });
  pubsub.publish(`POST_ADDED_${post.authorId}`, { postAdded: post });

  return post;
};
</code></pre>
<h2>服务器配置和中间件</h2>
<h3>Apollo Server配置</h3>
<pre><code class="language-javascript">const { ApolloServer } = require('apollo-server-express');
const express = require('express');

class GraphQLServer {
  constructor() {
    this.app = express();
    this.cacheManager = new CacheManager();
    this.setupApolloServer();
  }

  setupApolloServer() {
    this.server = new ApolloServer({
      typeDefs: schema,
      resolvers,
      dataSources: () =&gt; ({
        userAPI: new OptimizedUserAPI(database),
        postAPI: new PostAPI(),
        commentAPI: new CommentAPI(database)
      }),
      context: ({ req, connection }) =&gt; {
        // WebSocket连接（订阅）
        if (connection) {
          return {
            user: connection.context.user,
            cache: this.cacheManager
          };
        }

        // HTTP请求
        return {
          user: this.getUserFromToken(req.headers.authorization),
          cache: this.cacheManager,
          req
        };
      },
      validationRules,
      subscriptions: {
        path: '/graphql',
        onConnect: async (connectionParams, webSocket) =&gt; {
          // 验证WebSocket连接
          const token = connectionParams.authorization;
          const user = await this.getUserFromToken(token);

          if (!user) {
            throw new Error('Authentication failed');
          }

          return { user };
        },
        onDisconnect: (webSocket, context) =&gt; {
          console.log('Client disconnected');
        }
      },
      introspection: process.env.NODE_ENV !== 'production',
      playground: process.env.NODE_ENV !== 'production',
      debug: process.env.NODE_ENV !== 'production'
    });
  }

  async start() {
    await this.server.start();
    this.server.applyMiddleware({ 
      app: this.app, 
      path: '/graphql',
      cors: {
        origin: process.env.ALLOWED_ORIGINS?.split(',') || ['http://localhost:3000'],
        credentials: true
      }
    });

    const httpServer = require('http').createServer(this.app);
    this.server.installSubscriptionHandlers(httpServer);

    const PORT = process.env.PORT || 4000;
    httpServer.listen(PORT, () =&gt; {
      console.log(`🚀 Server ready at http://localhost:${PORT}${this.server.graphqlPath}`);
      console.log(`🚀 Subscriptions ready at ws://localhost:${PORT}${this.server.subscriptionsPath}`);
    });
  }

  getUserFromToken(token) {
    // 实现JWT令牌验证逻辑
    if (!token) return null;

    try {
      const cleanToken = token.replace('Bearer ', '');
      return jwt.verify(cleanToken, process.env.JWT_SECRET);
    } catch (error) {
      return null;
    }
  }
}
</code></pre>
<h3>性能监控</h3>
<pre><code class="language-javascript">const { GraphQLRequestMetrics } = require('apollo-server-monitoring');

class GraphQLMonitoring {
  constructor() {
    this.metrics = {
      queryCount: 0,
      mutationCount: 0,
      subscriptionCount: 0,
      averageResponseTime: 0,
      errorCount: 0,
      complexQueries: []
    };
  }

  createMetricsPlugin() {
    return {
      requestDidStart() {
        const startTime = Date.now();

        return {
          didResolveOperation(requestContext) {
            const { operation } = requestContext.request;

            switch (operation.operation) {
              case 'query':
                this.metrics.queryCount++;
                break;
              case 'mutation':
                this.metrics.mutationCount++;
                break;
              case 'subscription':
                this.metrics.subscriptionCount++;
                break;
            }
          },

          didEncounterErrors(requestContext) {
            this.metrics.errorCount++;
            console.error('GraphQL errors:', requestContext.errors);
          },

          willSendResponse(requestContext) {
            const duration = Date.now() - startTime;

            // 更新平均响应时间
            this.updateAverageResponseTime(duration);

            // 记录复杂查询
            if (duration &gt; 1000) { // 超过1秒的查询
              this.metrics.complexQueries.push({
                query: requestContext.request.query,
                duration,
                timestamp: new Date().toISOString()
              });

              // 只保留最近的10个复杂查询
              if (this.metrics.complexQueries.length &gt; 10) {
                this.metrics.complexQueries.shift();
              }
            }
          }
        };
      }
    };
  }

  updateAverageResponseTime(duration) {
    const totalRequests = this.metrics.queryCount + 
                         this.metrics.mutationCount + 
                         this.metrics.subscriptionCount;

    if (totalRequests === 1) {
      this.metrics.averageResponseTime = duration;
    } else {
      this.metrics.averageResponseTime = 
        (this.metrics.averageResponseTime * (totalRequests - 1) + duration) / totalRequests;
    }
  }

  getMetrics() {
    return {
      ...this.metrics,
      timestamp: new Date().toISOString()
    };
  }
}
</code></pre>
<h2>客户端集成</h2>
<h3>React Apollo Client配置</h3>
<pre><code class="language-javascript">import { ApolloClient, InMemoryCache, from, createHttpLink } from '@apollo/client';
import { setContext } from '@apollo/client/link/context';
import { onError } from '@apollo/client/link/error';
import { WebSocketLink } from '@apollo/client/link/ws';
import { getMainDefinition } from '@apollo/client/utilities';

class GraphQLClient {
  constructor() {
    this.setupClient();
  }

  setupClient() {
    // HTTP链接
    const httpLink = createHttpLink({
      uri: process.env.REACT_APP_GRAPHQL_ENDPOINT || 'http://localhost:4000/graphql',
    });

    // WebSocket链接（用于订阅）
    const wsLink = new WebSocketLink({
      uri: process.env.REACT_APP_GRAPHQL_WS_ENDPOINT || 'ws://localhost:4000/graphql',
      options: {
        reconnect: true,
        connectionParams: {
          authorization: localStorage.getItem('token'),
        },
      },
    });

    // 认证链接
    const authLink = setContext((_, { headers }) =&gt; {
      const token = localStorage.getItem('token');

      return {
        headers: {
          ...headers,
          authorization: token ? `Bearer ${token}` : &quot;&quot;,
        }
      };
    });

    // 错误处理链接
    const errorLink = onError(({ graphQLErrors, networkError, operation, forward }) =&gt; {
      if (graphQLErrors) {
        graphQLErrors.forEach(({ message, locations, path }) =&gt; {
          console.error(
            `GraphQL error: Message: ${message}, Location: ${locations}, Path: ${path}`
          );
        });
      }

      if (networkError) {
        console.error(`Network error: ${networkError}`);

        if (networkError.statusCode === 401) {
          // 处理认证错误
          localStorage.removeItem('token');
          window.location.href = '/login';
        }
      }
    });

    // 分离HTTP和WebSocket流量
    const splitLink = split(
      ({ query }) =&gt; {
        const definition = getMainDefinition(query);
        return (
          definition.kind === 'OperationDefinition' &amp;&amp;
          definition.operation === 'subscription'
        );
      },
      wsLink,
      from([errorLink, authLink, httpLink])
    );

    this.client = new ApolloClient({
      link: splitLink,
      cache: new InMemoryCache({
        typePolicies: {
          User: {
            fields: {
              posts: {
                merge(existing = [], incoming = []) {
                  return [...existing, ...incoming];
                }
              }
            }
          },
          Post: {
            fields: {
              comments: {
                merge(existing = [], incoming = []) {
                  return [...existing, ...incoming];
                }
              }
            }
          }
        }
      }),
      defaultOptions: {
        watchQuery: {
          fetchPolicy: 'cache-and-network',
          errorPolicy: 'all'
        }
      }
    });
  }

  getClient() {
    return this.client;
  }
}

export default new GraphQLClient().getClient();
</code></pre>
<h2>测试策略</h2>
<h3>单元测试</h3>
<pre><code class="language-javascript">const { graphql } = require('graphql');
const { schema } = require('../schema');

describe('GraphQL Schema', () =&gt; {
  test('should fetch user by ID', async () =&gt; {
    const query = `
      query GetUser($id: String!) {
        user(id: $id) {
          id
          name
          email
        }
      }
    `;

    const mockContext = {
      dataSources: {
        userAPI: {
          getUserById: jest.fn().mockResolvedValue({
            id: '1',
            name: 'John Doe',
            email: 'john@example.com'
          })
        }
      }
    };

    const result = await graphql({
      schema,
      source: query,
      variableValues: { id: '1' },
      contextValue: mockContext
    });

    expect(result.errors).toBeUndefined();
    expect(result.data.user).toEqual({
      id: '1',
      name: 'John Doe',
      email: 'john@example.com'
    });
  });

  test('should handle user not found', async () =&gt; {
    const query = `
      query GetUser($id: String!) {
        user(id: $id) {
          id
          name
        }
      }
    `;

    const mockContext = {
      dataSources: {
        userAPI: {
          getUserById: jest.fn().mockResolvedValue(null)
        }
      }
    };

    const result = await graphql({
      schema,
      source: query,
      variableValues: { id: '999' },
      contextValue: mockContext
    });

    expect(result.errors).toBeUndefined();
    expect(result.data.user).toBeNull();
  });
});
</code></pre>
<h3>集成测试</h3>
<pre><code class="language-javascript">const { ApolloServer } = require('apollo-server-express');
const { createTestClient } = require('apollo-server-testing');

describe('GraphQL Integration Tests', () =&gt; {
  let server;
  let query, mutate;

  beforeEach(() =&gt; {
    server = new ApolloServer({
      typeDefs: schema,
      dataSources: () =&gt; ({
        userAPI: new MockUserAPI(),
        postAPI: new MockPostAPI()
      })
    });

    const testClient = createTestClient(server);
    query = testClient.query;
    mutate = testClient.mutate;
  });

  test('should create and fetch user', async () =&gt; {
    // 创建用户
    const createMutation = `
      mutation CreateUser($input: CreateUserInput!) {
        createUser(input: $input) {
          id
          name
          email
        }
      }
    `;

    const createResult = await mutate({
      mutation: createMutation,
      variables: {
        input: {
          name: 'Test User',
          email: 'test@example.com',
          password: 'password123'
        }
      }
    });

    expect(createResult.errors).toBeUndefined();
    const userId = createResult.data.createUser.id;

    // 查询用户
    const userQuery = `
      query GetUser($id: String!) {
        user(id: $id) {
          id
          name
          email
        }
      }
    `;

    const queryResult = await query({
      query: userQuery,
      variables: { id: userId }
    });

    expect(queryResult.errors).toBeUndefined();
    expect(queryResult.data.user.name).toBe('Test User');
  });
});
</code></pre>
<h2>总结与最佳实践</h2>

为满足能源场景中多数据类型融合、多终端协同和多业务系统接入的现实需求，轻量化引擎不仅要支持多模态数据的集成加载，还需具备灵活的模块化扩展能力。本模块旨在构建统一的数据解析与交互架构，支持几何、属性、逻辑、语义等多类型信息协同驱动，实现对模型的全面理解与操作响应。同时，通过开放标准化接口和模块插件机制，提升系统整体的生态兼容性与集成效率。

能源资产的全景表达不仅包括三维几何形态，还涉及其属性状态、结构逻辑、运行行为等多维度信息。该子模块需实现引擎对多模态数据的协同加载与联动表达，构建统一的数据映射机制，使几何构件与其对应的运行参数、设备属性、维护记录等信息能够实时绑定与同步展现。引擎还应支持与全时空分析引擎联动，借助时间轴控制、关系图谱、数据面板等方式，实现跨数据维度的可视化联动与实时分析。通过集成多模态信息，用户可基于模型同时完成查看、编辑、查询、分析等多种任务，推动从静态展示向智能交互演进。

系统应对规划图模中的电网拓扑结构进行分析，自动识别形成电气孤岛的区域。孤岛判定逻辑基于拓扑图的连通性分析，识别与主网断开的节点集合，并标注其所属区域、电压等级、负荷情况等属性。识别结果需支持结构化输出与图形化标记，可按照区块、设备类型等维度进行分类。系统还应评估孤岛区域的运行风险（如负荷丢失、供电能力不足)并输出评估指标，为后续处理与规划方案优化提供依据。

<h3>关键收获</h3>
<ol>
<li><strong>Schema设计</strong>：合理的类型定义和关系设计是GraphQL API成功的基础</li>
<li><strong>性能优化</strong>：DataLoader、缓存策略和查询复杂度控制缺一不可</li>
<li><strong>错误处理</strong>：完善的错误处理机制提升用户体验</li>
<li><strong>监控告警</strong>：实时监控和性能分析帮助持续优化</li>
</ol>
<h3>最佳实践总结</h3>
<ol>
<li><strong>使用DataLoader解决N+1查询问题</strong></li>
<li><strong>实施查询复杂度限制和深度限制</strong></li>
<li><strong>设计合理的缓存策略</strong></li>
<li><strong>提供详细的错误信息和状态码</strong></li>
<li><strong>建立完整的测试覆盖</strong></li>
<li><strong>监控性能指标和慢查询</strong></li>
</ol>
<p>GraphQL为前端开发提供了更大的灵活性，但也需要后端做好相应的性能优化和安全控制。通过合理的架构设计和优化策略，GraphQL可以显著提升开发效率和用户体验。</p>
                </div>
            </article>
        </div>
    </main>
    
    <footer>
        <p>&copy; 2025 我的博客. All rights reserved.</p>
    </footer>
</body>
</html>