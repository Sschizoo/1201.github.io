<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GraphQL APIè®¾è®¡ä¸æ€§èƒ½ä¼˜åŒ–å®æˆ˜ - æˆ‘çš„åšå®¢</title>
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <header>
        <h1 class="slogan">è®°å½•æ€è€ƒï¼Œåˆ†äº«ç”Ÿæ´»</h1>
    </header>
    
    <main>
        <div class="container">
            <a href="../index.html" class="back-link">â† è¿”å›é¦–é¡µ</a>
            
            <article class="article-page">
                <div class="article-header">
                    <h1>GraphQL APIè®¾è®¡ä¸æ€§èƒ½ä¼˜åŒ–å®æˆ˜</h1>
                    <p class="article-date">2025å¹´07æœˆ03æ—¥</p>
                </div>
                
                <div class="article-content">
                    <p><strong>Date: May 3, 2024</strong></p>
<p>éšç€å‰ç«¯åº”ç”¨å¤æ‚åº¦çš„å¢åŠ ï¼Œä¼ ç»Ÿçš„REST APIå¼€å§‹æš´éœ²å‡ºä¸€äº›é™åˆ¶ã€‚GraphQLä½œä¸ºä¸€ç§æ–°çš„APIæŸ¥è¯¢è¯­è¨€ï¼Œä¸ºæˆ‘ä»¬æä¾›äº†æ›´çµæ´»çš„æ•°æ®è·å–æ–¹å¼ã€‚ä»Šå¤©åˆ†äº«ä¸€ä¸‹æˆ‘åœ¨GraphQL APIè®¾è®¡å’Œæ€§èƒ½ä¼˜åŒ–æ–¹é¢çš„å®è·µç»éªŒã€‚</p>
<h2>GraphQLåŸºç¡€æ¶æ„æ­å»º</h2>
<h3>åŸºç¡€Schemaè®¾è®¡</h3>
<pre><code class="language-javascript">const { GraphQLSchema, GraphQLObjectType, GraphQLString, GraphQLInt, GraphQLList, GraphQLNonNull } = require('graphql');

// ç”¨æˆ·ç±»å‹å®šä¹‰
const UserType = new GraphQLObjectType({
  name: 'User',
  description: 'A user in our application',
  fields: () =&gt; ({
    id: {
      type: GraphQLNonNull(GraphQLString),
      description: 'The unique identifier for the user'
    },
    name: {
      type: GraphQLNonNull(GraphQLString),
      description: 'The user\'s full name'
    },
    email: {
      type: GraphQLNonNull(GraphQLString),
      description: 'The user\'s email address'
    },
    posts: {
      type: GraphQLList(PostType),
      description: 'Posts created by this user',
      resolve: async (user, args, context) =&gt; {
        return await context.dataSources.postAPI.getPostsByUserId(user.id);
      }
    },
    followers: {
      type: GraphQLList(UserType),
      description: 'Users following this user',
      resolve: async (user, args, context) =&gt; {
        return await context.dataSources.userAPI.getFollowers(user.id);
      }
    },
    followersCount: {
      type: GraphQLInt,
      description: 'Number of followers',
      resolve: async (user, args, context) =&gt; {
        // ä¼˜åŒ–ï¼šåªè¿”å›æ•°é‡ï¼Œä¸æŸ¥è¯¢å®Œæ•´ç”¨æˆ·ä¿¡æ¯
        return await context.dataSources.userAPI.getFollowersCount(user.id);
      }
    }
  })
});

// æ–‡ç« ç±»å‹å®šä¹‰
const PostType = new GraphQLObjectType({
  name: 'Post',
  description: 'A blog post',
  fields: () =&gt; ({
    id: {
      type: GraphQLNonNull(GraphQLString),
      description: 'The unique identifier for the post'
    },
    title: {
      type: GraphQLNonNull(GraphQLString),
      description: 'The post title'
    },
    content: {
      type: GraphQLString,
      description: 'The post content'
    },
    author: {
      type: UserType,
      description: 'The author of this post',
      resolve: async (post, args, context) =&gt; {
        return await context.dataSources.userAPI.getUserById(post.authorId);
      }
    },
    comments: {
      type: GraphQLList(CommentType),
      description: 'Comments on this post',
      args: {
        limit: { type: GraphQLInt, defaultValue: 10 },
        offset: { type: GraphQLInt, defaultValue: 0 }
      },
      resolve: async (post, args, context) =&gt; {
        return await context.dataSources.commentAPI.getCommentsByPostId(
          post.id, 
          args.limit, 
          args.offset
        );
      }
    },
    createdAt: {
      type: GraphQLString,
      description: 'When the post was created'
    }
  })
});

// è¯„è®ºç±»å‹å®šä¹‰
const CommentType = new GraphQLObjectType({
  name: 'Comment',
  description: 'A comment on a post',
  fields: () =&gt; ({
    id: {
      type: GraphQLNonNull(GraphQLString)
    },
    content: {
      type: GraphQLNonNull(GraphQLString)
    },
    author: {
      type: UserType,
      resolve: async (comment, args, context) =&gt; {
        return await context.dataSources.userAPI.getUserById(comment.authorId);
      }
    },
    post: {
      type: PostType,
      resolve: async (comment, args, context) =&gt; {
        return await context.dataSources.postAPI.getPostById(comment.postId);
      }
    },
    createdAt: {
      type: GraphQLString
    }
  })
});
</code></pre>
<h3>æŸ¥è¯¢å’Œå˜æ›´å®šä¹‰</h3>
<pre><code class="language-javascript">const { GraphQLInputObjectType } = require('graphql');

// è¾“å…¥ç±»å‹å®šä¹‰
const CreateUserInput = new GraphQLInputObjectType({
  name: 'CreateUserInput',
  fields: {
    name: { type: GraphQLNonNull(GraphQLString) },
    email: { type: GraphQLNonNull(GraphQLString) },
    password: { type: GraphQLNonNull(GraphQLString) }
  }
});

const CreatePostInput = new GraphQLInputObjectType({
  name: 'CreatePostInput',
  fields: {
    title: { type: GraphQLNonNull(GraphQLString) },
    content: { type: GraphQLString },
    authorId: { type: GraphQLNonNull(GraphQLString) }
  }
});

// æŸ¥è¯¢æ ¹ç±»å‹
const RootQuery = new GraphQLObjectType({
  name: 'RootQueryType',
  description: 'The root query type',
  fields: {
    user: {
      type: UserType,
      description: 'Get a single user by ID',
      args: {
        id: { type: GraphQLNonNull(GraphQLString) }
      },
      resolve: async (parent, args, context) =&gt; {
        return await context.dataSources.userAPI.getUserById(args.id);
      }
    },
    users: {
      type: GraphQLList(UserType),
      description: 'Get a list of users',
      args: {
        limit: { type: GraphQLInt, defaultValue: 10 },
        offset: { type: GraphQLInt, defaultValue: 0 },
        search: { type: GraphQLString }
      },
      resolve: async (parent, args, context) =&gt; {
        return await context.dataSources.userAPI.getUsers(args);
      }
    },
    post: {
      type: PostType,
      description: 'Get a single post by ID',
      args: {
        id: { type: GraphQLNonNull(GraphQLString) }
      },
      resolve: async (parent, args, context) =&gt; {
        return await context.dataSources.postAPI.getPostById(args.id);
      }
    },
    posts: {
      type: GraphQLList(PostType),
      description: 'Get a list of posts',
      args: {
        limit: { type: GraphQLInt, defaultValue: 10 },
        offset: { type: GraphQLInt, defaultValue: 0 },
        authorId: { type: GraphQLString }
      },
      resolve: async (parent, args, context) =&gt; {
        if (args.authorId) {
          return await context.dataSources.postAPI.getPostsByUserId(args.authorId);
        }
        return await context.dataSources.postAPI.getPosts(args);
      }
    }
  }
});

// å˜æ›´æ ¹ç±»å‹
const RootMutation = new GraphQLObjectType({
  name: 'RootMutationType',
  description: 'The root mutation type',
  fields: {
    createUser: {
      type: UserType,
      description: 'Create a new user',
      args: {
        input: { type: GraphQLNonNull(CreateUserInput) }
      },
      resolve: async (parent, args, context) =&gt; {
        return await context.dataSources.userAPI.createUser(args.input);
      }
    },
    createPost: {
      type: PostType,
      description: 'Create a new post',
      args: {
        input: { type: GraphQLNonNull(CreatePostInput) }
      },
      resolve: async (parent, args, context) =&gt; {
        return await context.dataSources.postAPI.createPost(args.input);
      }
    },
    updatePost: {
      type: PostType,
      description: 'Update an existing post',
      args: {
        id: { type: GraphQLNonNull(GraphQLString) },
        input: { type: CreatePostInput }
      },
      resolve: async (parent, args, context) =&gt; {
        return await context.dataSources.postAPI.updatePost(args.id, args.input);
      }
    },
    deletePost: {
      type: GraphQLString,
      description: 'Delete a post',
      args: {
        id: { type: GraphQLNonNull(GraphQLString) }
      },
      resolve: async (parent, args, context) =&gt; {
        await context.dataSources.postAPI.deletePost(args.id);
        return 'Post deleted successfully';
      }
    }
  }
});

// åˆ›å»ºSchema
const schema = new GraphQLSchema({
  query: RootQuery,
  mutation: RootMutation
});
</code></pre>
<h2>æ•°æ®æºå±‚è®¾è®¡</h2>
<h3>RESTful APIæ•°æ®æº</h3>
<pre><code class="language-javascript">const { RESTDataSource } = require('apollo-datasource-rest');

class UserAPI extends RESTDataSource {
  constructor() {
    super();
    this.baseURL = 'http://localhost:3001/api/';
  }

  async getUserById(id) {
    const user = await this.get(`users/${id}`);
    return this.userReducer(user);
  }

  async getUsers({ limit, offset, search }) {
    const params = { limit, offset };
    if (search) {
      params.search = search;
    }

    const response = await this.get('users', params);
    return response.users.map(user =&gt; this.userReducer(user));
  }

  async createUser(userData) {
    const response = await this.post('users', userData);
    return this.userReducer(response.user);
  }

  async getFollowers(userId) {
    const response = await this.get(`users/${userId}/followers`);
    return response.followers.map(user =&gt; this.userReducer(user));
  }

  async getFollowersCount(userId) {
    const response = await this.get(`users/${userId}/followers/count`);
    return response.count;
  }

  // æ•°æ®è½¬æ¢å™¨ï¼Œç»Ÿä¸€æ•°æ®æ ¼å¼
  userReducer(user) {
    return {
      id: user.id,
      name: user.name,
      email: user.email,
      createdAt: user.created_at,
      // æ·»åŠ å…¶ä»–å¿…è¦çš„å­—æ®µè½¬æ¢
    };
  }
}

class PostAPI extends RESTDataSource {
  constructor() {
    super();
    this.baseURL = 'http://localhost:3002/api/';
  }

  async getPostById(id) {
    const post = await this.get(`posts/${id}`);
    return this.postReducer(post);
  }

  async getPosts({ limit, offset }) {
    const response = await this.get('posts', { limit, offset });
    return response.posts.map(post =&gt; this.postReducer(post));
  }

  async getPostsByUserId(userId) {
    const response = await this.get(`posts?authorId=${userId}`);
    return response.posts.map(post =&gt; this.postReducer(post));
  }

  async createPost(postData) {
    const response = await this.post('posts', postData);
    return this.postReducer(response.post);
  }

  async updatePost(id, postData) {
    const response = await this.put(`posts/${id}`, postData);
    return this.postReducer(response.post);
  }

  async deletePost(id) {
    await this.delete(`posts/${id}`);
    return true;
  }

  postReducer(post) {
    return {
      id: post.id,
      title: post.title,
      content: post.content,
      authorId: post.author_id,
      createdAt: post.created_at,
      updatedAt: post.updated_at
    };
  }
}
</code></pre>
<h3>æ•°æ®åº“æ•°æ®æº</h3>
<pre><code class="language-javascript">const { DataSource } = require('apollo-datasource');

class DatabaseAPI extends DataSource {
  constructor(database) {
    super();
    this.db = database;
  }

  initialize(config) {
    this.context = config.context;
    this.cache = config.cache;
  }

  async getUserById(id) {
    // å°è¯•ä»ç¼“å­˜è·å–
    const cacheKey = `user:${id}`;
    const cached = await this.cache.get(cacheKey);

    if (cached) {
      return JSON.parse(cached);
    }

    // ä»æ•°æ®åº“æŸ¥è¯¢
    const query = 'SELECT * FROM users WHERE id = ?';
    const result = await this.db.query(query, [id]);

    if (result.length === 0) {
      return null;
    }

    const user = this.userReducer(result[0]);

    // ç¼“å­˜ç»“æœ
    await this.cache.set(cacheKey, JSON.stringify(user), { ttl: 300 });

    return user;
  }

  async getUsersByIds(ids) {
    if (ids.length === 0) return [];

    // æ‰¹é‡æŸ¥è¯¢å‡å°‘æ•°æ®åº“è®¿é—®
    const placeholders = ids.map(() =&gt; '?').join(',');
    const query = `SELECT * FROM users WHERE id IN (${placeholders})`;
    const results = await this.db.query(query, ids);

    return results.map(user =&gt; this.userReducer(user));
  }

  userReducer(user) {
    return {
      id: user.id.toString(),
      name: user.name,
      email: user.email,
      createdAt: user.created_at.toISOString()
    };
  }
}
</code></pre>
<h2>æ€§èƒ½ä¼˜åŒ–ç­–ç•¥</h2>
<h3>DataLoaderè§£å†³N+1æŸ¥è¯¢é—®é¢˜</h3>
<pre><code class="language-javascript">const DataLoader = require('dataloader');

class OptimizedUserAPI extends DatabaseAPI {
  constructor(database) {
    super(database);

    // åˆ›å»ºDataLoaderå®ä¾‹
    this.userLoader = new DataLoader(async (userIds) =&gt; {
      const users = await this.getUsersByIds(userIds);

      // ç¡®ä¿è¿”å›çš„æ•°ç»„é¡ºåºä¸è¯·æ±‚çš„IDé¡ºåºä¸€è‡´
      const userMap = new Map(users.map(user =&gt; [user.id, user]));
      return userIds.map(id =&gt; userMap.get(id) || null);
    });

    this.postsByUserLoader = new DataLoader(async (userIds) =&gt; {
      const posts = await this.getPostsByUserIds(userIds);

      // æŒ‰ç”¨æˆ·IDåˆ†ç»„
      const postsByUser = userIds.map(userId =&gt; 
        posts.filter(post =&gt; post.authorId === userId)
      );

      return postsByUser;
    });
  }

  async getUserById(id) {
    return await this.userLoader.load(id);
  }

  async getPostsByUserId(userId) {
    const posts = await this.postsByUserLoader.load(userId);
    return posts;
  }

  async getPostsByUserIds(userIds) {
    if (userIds.length === 0) return [];

    const placeholders = userIds.map(() =&gt; '?').join(',');
    const query = `SELECT * FROM posts WHERE author_id IN (${placeholders}) ORDER BY created_at DESC`;
    const results = await this.db.query(query, userIds);

    return results.map(post =&gt; this.postReducer(post));
  }

  postReducer(post) {
    return {
      id: post.id.toString(),
      title: post.title,
      content: post.content,
      authorId: post.author_id.toString(),
      createdAt: post.created_at.toISOString()
    };
  }
}
</code></pre>
<h3>æŸ¥è¯¢å¤æ‚åº¦åˆ†æ</h3>
<pre><code class="language-javascript">const depthLimit = require('graphql-depth-limit');
const costAnalysis = require('graphql-cost-analysis');

// æŸ¥è¯¢æ·±åº¦é™åˆ¶
const depthLimitRule = depthLimit(10);

// æŸ¥è¯¢å¤æ‚åº¦åˆ†æ
const costAnalysisRule = costAnalysis.createRateLimitRule({
  createError: (max, actual) =&gt; {
    return new Error(`Query cost ${actual} exceeds maximum cost ${max}`);
  },
  maximumCost: 1000,
  scalarCost: 1,
  objectCost: 2,
  listFactor: 10,
  introspectionCost: 1000,
  fieldExtension: () =&gt; ({
    cost: ({ type, field, args }) =&gt; {
      // æ ¹æ®å­—æ®µç±»å‹åŠ¨æ€è®¡ç®—æˆæœ¬
      if (field.name === 'posts') {
        const limit = args.limit || 10;
        return limit * 2; // æ¯ä¸ªpostæˆæœ¬ä¸º2
      }

      if (field.name === 'followers') {
        return 50; // å…³æ³¨è€…æŸ¥è¯¢æˆæœ¬è¾ƒé«˜
      }

      return 1; // é»˜è®¤æˆæœ¬
    }
  })
});

// åº”ç”¨è§„åˆ™
const validationRules = [
  depthLimitRule,
  costAnalysisRule
];
</code></pre>
<h3>ç¼“å­˜ç­–ç•¥</h3>
<pre><code class="language-javascript">const Redis = require('redis');

class CacheManager {
  constructor() {
    this.redis = Redis.createClient();
    this.defaultTTL = 300; // 5åˆ†é’Ÿ
  }

  async get(key) {
    try {
      const data = await this.redis.get(key);
      return data ? JSON.parse(data) : null;
    } catch (error) {
      console.error('Cache get error:', error);
      return null;
    }
  }

  async set(key, value, ttl = this.defaultTTL) {
    try {
      await this.redis.setex(key, ttl, JSON.stringify(value));
    } catch (error) {
      console.error('Cache set error:', error);
    }
  }

  async invalidate(pattern) {
    try {
      const keys = await this.redis.keys(pattern);
      if (keys.length &gt; 0) {
        await this.redis.del(...keys);
      }
    } catch (error) {
      console.error('Cache invalidation error:', error);
    }
  }

  generateKey(prefix, id, fields = []) {
    const fieldHash = fields.sort().join(',');
    return `${prefix}:${id}:${this.hashString(fieldHash)}`;
  }

  hashString(str) {
    let hash = 0;
    for (let i = 0; i &lt; str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash &lt;&lt; 5) - hash) + char;
      hash = hash &amp; hash; // è½¬æ¢ä¸º32ä½æ•´æ•°
    }
    return Math.abs(hash);
  }
}

// åŸºäºå­—æ®µçš„ç¼“å­˜ç­–ç•¥
class FieldLevelCache {
  constructor(cacheManager) {
    this.cache = cacheManager;
  }

  async resolveWithCache(type, id, fields, resolver) {
    const cacheKey = this.cache.generateKey(type, id, fields);
    let data = await this.cache.get(cacheKey);

    if (!data) {
      data = await resolver();
      if (data) {
        await this.cache.set(cacheKey, data);
      }
    }

    return data;
  }

  invalidateType(type, id) {
    const pattern = `${type}:${id}:*`;
    return this.cache.invalidate(pattern);
  }
}
</code></pre>
<h3>è®¢é˜…å’Œå®æ—¶æ›´æ–°</h3>
<pre><code class="language-javascript">const { PubSub } = require('graphql-subscriptions');
const { GraphQLSubscription } = require('graphql');

const pubsub = new PubSub();

// è®¢é˜…ç±»å‹å®šä¹‰
const RootSubscription = new GraphQLObjectType({
  name: 'RootSubscriptionType',
  fields: {
    postAdded: {
      type: PostType,
      description: 'Subscribe to new posts',
      args: {
        authorId: { type: GraphQLString }
      },
      subscribe: (parent, args) =&gt; {
        const channel = args.authorId ? 
          `POST_ADDED_${args.authorId}` : 
          'POST_ADDED';

        return pubsub.asyncIterator(channel);
      }
    },
    commentAdded: {
      type: CommentType,
      description: 'Subscribe to new comments on a post',
      args: {
        postId: { type: GraphQLNonNull(GraphQLString) }
      },
      subscribe: (parent, args) =&gt; {
        return pubsub.asyncIterator(`COMMENT_ADDED_${args.postId}`);
      }
    }
  }
});

// åœ¨Mutationä¸­å‘å¸ƒäº‹ä»¶
const createPostWithSubscription = async (parent, args, context) =&gt; {
  const post = await context.dataSources.postAPI.createPost(args.input);

  // å‘å¸ƒäº‹ä»¶
  pubsub.publish('POST_ADDED', { postAdded: post });
  pubsub.publish(`POST_ADDED_${post.authorId}`, { postAdded: post });

  return post;
};
</code></pre>
<h2>æœåŠ¡å™¨é…ç½®å’Œä¸­é—´ä»¶</h2>
<h3>Apollo Serveré…ç½®</h3>
<pre><code class="language-javascript">const { ApolloServer } = require('apollo-server-express');
const express = require('express');

class GraphQLServer {
  constructor() {
    this.app = express();
    this.cacheManager = new CacheManager();
    this.setupApolloServer();
  }

  setupApolloServer() {
    this.server = new ApolloServer({
      typeDefs: schema,
      resolvers,
      dataSources: () =&gt; ({
        userAPI: new OptimizedUserAPI(database),
        postAPI: new PostAPI(),
        commentAPI: new CommentAPI(database)
      }),
      context: ({ req, connection }) =&gt; {
        // WebSocketè¿æ¥ï¼ˆè®¢é˜…ï¼‰
        if (connection) {
          return {
            user: connection.context.user,
            cache: this.cacheManager
          };
        }

        // HTTPè¯·æ±‚
        return {
          user: this.getUserFromToken(req.headers.authorization),
          cache: this.cacheManager,
          req
        };
      },
      validationRules,
      subscriptions: {
        path: '/graphql',
        onConnect: async (connectionParams, webSocket) =&gt; {
          // éªŒè¯WebSocketè¿æ¥
          const token = connectionParams.authorization;
          const user = await this.getUserFromToken(token);

          if (!user) {
            throw new Error('Authentication failed');
          }

          return { user };
        },
        onDisconnect: (webSocket, context) =&gt; {
          console.log('Client disconnected');
        }
      },
      introspection: process.env.NODE_ENV !== 'production',
      playground: process.env.NODE_ENV !== 'production',
      debug: process.env.NODE_ENV !== 'production'
    });
  }

  async start() {
    await this.server.start();
    this.server.applyMiddleware({ 
      app: this.app, 
      path: '/graphql',
      cors: {
        origin: process.env.ALLOWED_ORIGINS?.split(',') || ['http://localhost:3000'],
        credentials: true
      }
    });

    const httpServer = require('http').createServer(this.app);
    this.server.installSubscriptionHandlers(httpServer);

    const PORT = process.env.PORT || 4000;
    httpServer.listen(PORT, () =&gt; {
      console.log(`ğŸš€ Server ready at http://localhost:${PORT}${this.server.graphqlPath}`);
      console.log(`ğŸš€ Subscriptions ready at ws://localhost:${PORT}${this.server.subscriptionsPath}`);
    });
  }

  getUserFromToken(token) {
    // å®ç°JWTä»¤ç‰ŒéªŒè¯é€»è¾‘
    if (!token) return null;

    try {
      const cleanToken = token.replace('Bearer ', '');
      return jwt.verify(cleanToken, process.env.JWT_SECRET);
    } catch (error) {
      return null;
    }
  }
}
</code></pre>
<h3>æ€§èƒ½ç›‘æ§</h3>
<pre><code class="language-javascript">const { GraphQLRequestMetrics } = require('apollo-server-monitoring');

class GraphQLMonitoring {
  constructor() {
    this.metrics = {
      queryCount: 0,
      mutationCount: 0,
      subscriptionCount: 0,
      averageResponseTime: 0,
      errorCount: 0,
      complexQueries: []
    };
  }

  createMetricsPlugin() {
    return {
      requestDidStart() {
        const startTime = Date.now();

        return {
          didResolveOperation(requestContext) {
            const { operation } = requestContext.request;

            switch (operation.operation) {
              case 'query':
                this.metrics.queryCount++;
                break;
              case 'mutation':
                this.metrics.mutationCount++;
                break;
              case 'subscription':
                this.metrics.subscriptionCount++;
                break;
            }
          },

          didEncounterErrors(requestContext) {
            this.metrics.errorCount++;
            console.error('GraphQL errors:', requestContext.errors);
          },

          willSendResponse(requestContext) {
            const duration = Date.now() - startTime;

            // æ›´æ–°å¹³å‡å“åº”æ—¶é—´
            this.updateAverageResponseTime(duration);

            // è®°å½•å¤æ‚æŸ¥è¯¢
            if (duration &gt; 1000) { // è¶…è¿‡1ç§’çš„æŸ¥è¯¢
              this.metrics.complexQueries.push({
                query: requestContext.request.query,
                duration,
                timestamp: new Date().toISOString()
              });

              // åªä¿ç•™æœ€è¿‘çš„10ä¸ªå¤æ‚æŸ¥è¯¢
              if (this.metrics.complexQueries.length &gt; 10) {
                this.metrics.complexQueries.shift();
              }
            }
          }
        };
      }
    };
  }

  updateAverageResponseTime(duration) {
    const totalRequests = this.metrics.queryCount + 
                         this.metrics.mutationCount + 
                         this.metrics.subscriptionCount;

    if (totalRequests === 1) {
      this.metrics.averageResponseTime = duration;
    } else {
      this.metrics.averageResponseTime = 
        (this.metrics.averageResponseTime * (totalRequests - 1) + duration) / totalRequests;
    }
  }

  getMetrics() {
    return {
      ...this.metrics,
      timestamp: new Date().toISOString()
    };
  }
}
</code></pre>
<h2>å®¢æˆ·ç«¯é›†æˆ</h2>
<h3>React Apollo Clienté…ç½®</h3>
<pre><code class="language-javascript">import { ApolloClient, InMemoryCache, from, createHttpLink } from '@apollo/client';
import { setContext } from '@apollo/client/link/context';
import { onError } from '@apollo/client/link/error';
import { WebSocketLink } from '@apollo/client/link/ws';
import { getMainDefinition } from '@apollo/client/utilities';

class GraphQLClient {
  constructor() {
    this.setupClient();
  }

  setupClient() {
    // HTTPé“¾æ¥
    const httpLink = createHttpLink({
      uri: process.env.REACT_APP_GRAPHQL_ENDPOINT || 'http://localhost:4000/graphql',
    });

    // WebSocketé“¾æ¥ï¼ˆç”¨äºè®¢é˜…ï¼‰
    const wsLink = new WebSocketLink({
      uri: process.env.REACT_APP_GRAPHQL_WS_ENDPOINT || 'ws://localhost:4000/graphql',
      options: {
        reconnect: true,
        connectionParams: {
          authorization: localStorage.getItem('token'),
        },
      },
    });

    // è®¤è¯é“¾æ¥
    const authLink = setContext((_, { headers }) =&gt; {
      const token = localStorage.getItem('token');

      return {
        headers: {
          ...headers,
          authorization: token ? `Bearer ${token}` : &quot;&quot;,
        }
      };
    });

    // é”™è¯¯å¤„ç†é“¾æ¥
    const errorLink = onError(({ graphQLErrors, networkError, operation, forward }) =&gt; {
      if (graphQLErrors) {
        graphQLErrors.forEach(({ message, locations, path }) =&gt; {
          console.error(
            `GraphQL error: Message: ${message}, Location: ${locations}, Path: ${path}`
          );
        });
      }

      if (networkError) {
        console.error(`Network error: ${networkError}`);

        if (networkError.statusCode === 401) {
          // å¤„ç†è®¤è¯é”™è¯¯
          localStorage.removeItem('token');
          window.location.href = '/login';
        }
      }
    });

    // åˆ†ç¦»HTTPå’ŒWebSocketæµé‡
    const splitLink = split(
      ({ query }) =&gt; {
        const definition = getMainDefinition(query);
        return (
          definition.kind === 'OperationDefinition' &amp;&amp;
          definition.operation === 'subscription'
        );
      },
      wsLink,
      from([errorLink, authLink, httpLink])
    );

    this.client = new ApolloClient({
      link: splitLink,
      cache: new InMemoryCache({
        typePolicies: {
          User: {
            fields: {
              posts: {
                merge(existing = [], incoming = []) {
                  return [...existing, ...incoming];
                }
              }
            }
          },
          Post: {
            fields: {
              comments: {
                merge(existing = [], incoming = []) {
                  return [...existing, ...incoming];
                }
              }
            }
          }
        }
      }),
      defaultOptions: {
        watchQuery: {
          fetchPolicy: 'cache-and-network',
          errorPolicy: 'all'
        }
      }
    });
  }

  getClient() {
    return this.client;
  }
}

export default new GraphQLClient().getClient();
</code></pre>
<h2>æµ‹è¯•ç­–ç•¥</h2>
<h3>å•å…ƒæµ‹è¯•</h3>
<pre><code class="language-javascript">const { graphql } = require('graphql');
const { schema } = require('../schema');

describe('GraphQL Schema', () =&gt; {
  test('should fetch user by ID', async () =&gt; {
    const query = `
      query GetUser($id: String!) {
        user(id: $id) {
          id
          name
          email
        }
      }
    `;

    const mockContext = {
      dataSources: {
        userAPI: {
          getUserById: jest.fn().mockResolvedValue({
            id: '1',
            name: 'John Doe',
            email: 'john@example.com'
          })
        }
      }
    };

    const result = await graphql({
      schema,
      source: query,
      variableValues: { id: '1' },
      contextValue: mockContext
    });

    expect(result.errors).toBeUndefined();
    expect(result.data.user).toEqual({
      id: '1',
      name: 'John Doe',
      email: 'john@example.com'
    });
  });

  test('should handle user not found', async () =&gt; {
    const query = `
      query GetUser($id: String!) {
        user(id: $id) {
          id
          name
        }
      }
    `;

    const mockContext = {
      dataSources: {
        userAPI: {
          getUserById: jest.fn().mockResolvedValue(null)
        }
      }
    };

    const result = await graphql({
      schema,
      source: query,
      variableValues: { id: '999' },
      contextValue: mockContext
    });

    expect(result.errors).toBeUndefined();
    expect(result.data.user).toBeNull();
  });
});
</code></pre>
<h3>é›†æˆæµ‹è¯•</h3>
<pre><code class="language-javascript">const { ApolloServer } = require('apollo-server-express');
const { createTestClient } = require('apollo-server-testing');

describe('GraphQL Integration Tests', () =&gt; {
  let server;
  let query, mutate;

  beforeEach(() =&gt; {
    server = new ApolloServer({
      typeDefs: schema,
      dataSources: () =&gt; ({
        userAPI: new MockUserAPI(),
        postAPI: new MockPostAPI()
      })
    });

    const testClient = createTestClient(server);
    query = testClient.query;
    mutate = testClient.mutate;
  });

  test('should create and fetch user', async () =&gt; {
    // åˆ›å»ºç”¨æˆ·
    const createMutation = `
      mutation CreateUser($input: CreateUserInput!) {
        createUser(input: $input) {
          id
          name
          email
        }
      }
    `;

    const createResult = await mutate({
      mutation: createMutation,
      variables: {
        input: {
          name: 'Test User',
          email: 'test@example.com',
          password: 'password123'
        }
      }
    });

    expect(createResult.errors).toBeUndefined();
    const userId = createResult.data.createUser.id;

    // æŸ¥è¯¢ç”¨æˆ·
    const userQuery = `
      query GetUser($id: String!) {
        user(id: $id) {
          id
          name
          email
        }
      }
    `;

    const queryResult = await query({
      query: userQuery,
      variables: { id: userId }
    });

    expect(queryResult.errors).toBeUndefined();
    expect(queryResult.data.user.name).toBe('Test User');
  });
});
</code></pre>
<h2>æ€»ç»“ä¸æœ€ä½³å®è·µ</h2>

ä¸ºæ»¡è¶³èƒ½æºåœºæ™¯ä¸­å¤šæ•°æ®ç±»å‹èåˆã€å¤šç»ˆç«¯ååŒå’Œå¤šä¸šåŠ¡ç³»ç»Ÿæ¥å…¥çš„ç°å®éœ€æ±‚ï¼Œè½»é‡åŒ–å¼•æ“ä¸ä»…è¦æ”¯æŒå¤šæ¨¡æ€æ•°æ®çš„é›†æˆåŠ è½½ï¼Œè¿˜éœ€å…·å¤‡çµæ´»çš„æ¨¡å—åŒ–æ‰©å±•èƒ½åŠ›ã€‚æœ¬æ¨¡å—æ—¨åœ¨æ„å»ºç»Ÿä¸€çš„æ•°æ®è§£æä¸äº¤äº’æ¶æ„ï¼Œæ”¯æŒå‡ ä½•ã€å±æ€§ã€é€»è¾‘ã€è¯­ä¹‰ç­‰å¤šç±»å‹ä¿¡æ¯ååŒé©±åŠ¨ï¼Œå®ç°å¯¹æ¨¡å‹çš„å…¨é¢ç†è§£ä¸æ“ä½œå“åº”ã€‚åŒæ—¶ï¼Œé€šè¿‡å¼€æ”¾æ ‡å‡†åŒ–æ¥å£å’Œæ¨¡å—æ’ä»¶æœºåˆ¶ï¼Œæå‡ç³»ç»Ÿæ•´ä½“çš„ç”Ÿæ€å…¼å®¹æ€§ä¸é›†æˆæ•ˆç‡ã€‚

èƒ½æºèµ„äº§çš„å…¨æ™¯è¡¨è¾¾ä¸ä»…åŒ…æ‹¬ä¸‰ç»´å‡ ä½•å½¢æ€ï¼Œè¿˜æ¶‰åŠå…¶å±æ€§çŠ¶æ€ã€ç»“æ„é€»è¾‘ã€è¿è¡Œè¡Œä¸ºç­‰å¤šç»´åº¦ä¿¡æ¯ã€‚è¯¥å­æ¨¡å—éœ€å®ç°å¼•æ“å¯¹å¤šæ¨¡æ€æ•°æ®çš„ååŒåŠ è½½ä¸è”åŠ¨è¡¨è¾¾ï¼Œæ„å»ºç»Ÿä¸€çš„æ•°æ®æ˜ å°„æœºåˆ¶ï¼Œä½¿å‡ ä½•æ„ä»¶ä¸å…¶å¯¹åº”çš„è¿è¡Œå‚æ•°ã€è®¾å¤‡å±æ€§ã€ç»´æŠ¤è®°å½•ç­‰ä¿¡æ¯èƒ½å¤Ÿå®æ—¶ç»‘å®šä¸åŒæ­¥å±•ç°ã€‚å¼•æ“è¿˜åº”æ”¯æŒä¸å…¨æ—¶ç©ºåˆ†æå¼•æ“è”åŠ¨ï¼Œå€ŸåŠ©æ—¶é—´è½´æ§åˆ¶ã€å…³ç³»å›¾è°±ã€æ•°æ®é¢æ¿ç­‰æ–¹å¼ï¼Œå®ç°è·¨æ•°æ®ç»´åº¦çš„å¯è§†åŒ–è”åŠ¨ä¸å®æ—¶åˆ†æã€‚é€šè¿‡é›†æˆå¤šæ¨¡æ€ä¿¡æ¯ï¼Œç”¨æˆ·å¯åŸºäºæ¨¡å‹åŒæ—¶å®ŒæˆæŸ¥çœ‹ã€ç¼–è¾‘ã€æŸ¥è¯¢ã€åˆ†æç­‰å¤šç§ä»»åŠ¡ï¼Œæ¨åŠ¨ä»é™æ€å±•ç¤ºå‘æ™ºèƒ½äº¤äº’æ¼”è¿›ã€‚

ç³»ç»Ÿåº”å¯¹è§„åˆ’å›¾æ¨¡ä¸­çš„ç”µç½‘æ‹“æ‰‘ç»“æ„è¿›è¡Œåˆ†æï¼Œè‡ªåŠ¨è¯†åˆ«å½¢æˆç”µæ°”å­¤å²›çš„åŒºåŸŸã€‚å­¤å²›åˆ¤å®šé€»è¾‘åŸºäºæ‹“æ‰‘å›¾çš„è¿é€šæ€§åˆ†æï¼Œè¯†åˆ«ä¸ä¸»ç½‘æ–­å¼€çš„èŠ‚ç‚¹é›†åˆï¼Œå¹¶æ ‡æ³¨å…¶æ‰€å±åŒºåŸŸã€ç”µå‹ç­‰çº§ã€è´Ÿè·æƒ…å†µç­‰å±æ€§ã€‚è¯†åˆ«ç»“æœéœ€æ”¯æŒç»“æ„åŒ–è¾“å‡ºä¸å›¾å½¢åŒ–æ ‡è®°ï¼Œå¯æŒ‰ç…§åŒºå—ã€è®¾å¤‡ç±»å‹ç­‰ç»´åº¦è¿›è¡Œåˆ†ç±»ã€‚ç³»ç»Ÿè¿˜åº”è¯„ä¼°å­¤å²›åŒºåŸŸçš„è¿è¡Œé£é™©ï¼ˆå¦‚è´Ÿè·ä¸¢å¤±ã€ä¾›ç”µèƒ½åŠ›ä¸è¶³)å¹¶è¾“å‡ºè¯„ä¼°æŒ‡æ ‡ï¼Œä¸ºåç»­å¤„ç†ä¸è§„åˆ’æ–¹æ¡ˆä¼˜åŒ–æä¾›ä¾æ®ã€‚

<h3>å…³é”®æ”¶è·</h3>
<ol>
<li><strong>Schemaè®¾è®¡</strong>ï¼šåˆç†çš„ç±»å‹å®šä¹‰å’Œå…³ç³»è®¾è®¡æ˜¯GraphQL APIæˆåŠŸçš„åŸºç¡€</li>
<li><strong>æ€§èƒ½ä¼˜åŒ–</strong>ï¼šDataLoaderã€ç¼“å­˜ç­–ç•¥å’ŒæŸ¥è¯¢å¤æ‚åº¦æ§åˆ¶ç¼ºä¸€ä¸å¯</li>
<li><strong>é”™è¯¯å¤„ç†</strong>ï¼šå®Œå–„çš„é”™è¯¯å¤„ç†æœºåˆ¶æå‡ç”¨æˆ·ä½“éªŒ</li>
<li><strong>ç›‘æ§å‘Šè­¦</strong>ï¼šå®æ—¶ç›‘æ§å’Œæ€§èƒ½åˆ†æå¸®åŠ©æŒç»­ä¼˜åŒ–</li>
</ol>
<h3>æœ€ä½³å®è·µæ€»ç»“</h3>
<ol>
<li><strong>ä½¿ç”¨DataLoaderè§£å†³N+1æŸ¥è¯¢é—®é¢˜</strong></li>
<li><strong>å®æ–½æŸ¥è¯¢å¤æ‚åº¦é™åˆ¶å’Œæ·±åº¦é™åˆ¶</strong></li>
<li><strong>è®¾è®¡åˆç†çš„ç¼“å­˜ç­–ç•¥</strong></li>
<li><strong>æä¾›è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯å’ŒçŠ¶æ€ç </strong></li>
<li><strong>å»ºç«‹å®Œæ•´çš„æµ‹è¯•è¦†ç›–</strong></li>
<li><strong>ç›‘æ§æ€§èƒ½æŒ‡æ ‡å’Œæ…¢æŸ¥è¯¢</strong></li>
</ol>
<p>GraphQLä¸ºå‰ç«¯å¼€å‘æä¾›äº†æ›´å¤§çš„çµæ´»æ€§ï¼Œä½†ä¹Ÿéœ€è¦åç«¯åšå¥½ç›¸åº”çš„æ€§èƒ½ä¼˜åŒ–å’Œå®‰å…¨æ§åˆ¶ã€‚é€šè¿‡åˆç†çš„æ¶æ„è®¾è®¡å’Œä¼˜åŒ–ç­–ç•¥ï¼ŒGraphQLå¯ä»¥æ˜¾è‘—æå‡å¼€å‘æ•ˆç‡å’Œç”¨æˆ·ä½“éªŒã€‚</p>
                </div>
            </article>
        </div>
    </main>
    
    <footer>
        <p>&copy; 2025 æˆ‘çš„åšå®¢. All rights reserved.</p>
    </footer>
</body>
</html>