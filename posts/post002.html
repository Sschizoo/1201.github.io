<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>今日开发记录：React Hook 优化与性能调优实践 - 我的博客</title>
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <header>
        <h1 class="slogan">记录思考，分享生活</h1>
    </header>
    
    <main>
        <div class="container">
            <a href="../index.html" class="back-link">← 返回首页</a>
            
            <article class="article-page">
                <div class="article-header">
                    <h1>今日开发记录：React Hook 优化与性能调优实践</h1>
                    <p class="article-date">2025年07月03日</p>
                </div>
                
                <div class="article-content">
                    <p><strong>Date: January 22, 2024</strong></p>
<p>今天花了一整天时间优化项目中的React组件性能，遇到了一些有趣的问题和收获。记录一下今天的工作流程和思考。

系统需构建一套可配置的冲突修复策略，包括任务前后顺序优化、阶段合并或拆分、时间窗微调等方式。修复规则应支持用户设置优先级、缓评时间、资源重分配等参数，并结合优化算法生成可行的调整方案。对自动修复后的时间表系统应评估其资源占用、关键路径变化和工期变化情况，并提供版本对比与影响分析结果，以辅助规划人员评估调整效果。</p>
<h2>问题发现</h2>
<p>早上刚到公司，QA同事就反映说用户反馈系统在某些页面上操作比较卡顿，特别是在数据量大的列表页面。我立即打开Chrome DevTools开始分析。</p>
<h3>性能分析工具</h3>
<p>使用React DevTools Profiler进行性能分析时，发现了几个关键问题：</p>
<ol>
<li><strong>不必要的重新渲染</strong>：父组件的状态变化导致大量子组件重新渲染</li>
<li><strong>计算密集的操作</strong>：每次渲染都在执行复杂的数据处理逻辑</li>
<li><strong>内存泄漏</strong>：useEffect清理函数没有正确实现</li>
</ol>
<h2>优化策略</h2>
<h3>1. 使用 React.memo 优化子组件</h3>
<pre><code class="language-javascript">const ListItem = React.memo(({ item, onUpdate }) =&gt; {
  console.log('ListItem rendered:', item.id);

  return (
    &lt;div className=&quot;list-item&quot;&gt;
      &lt;h3&gt;{item.title}&lt;/h3&gt;
      &lt;p&gt;{item.description}&lt;/p&gt;
      &lt;button onClick={() =&gt; onUpdate(item.id)}&gt;Update&lt;/button&gt;
    &lt;/div&gt;
  );
});
</code></pre>
<p>通过React.memo包装子组件，当props没有变化时，组件就不会重新渲染。这个简单的优化就让我们的列表页面性能提升了约30%。</p>
<h3>2. useMemo 优化计算密集型操作</h3>
<pre><code class="language-javascript">const ExpensiveComponent = ({ data, filters }) =&gt; {
  const filteredData = useMemo(() =&gt; {
    console.log('Filtering data...');
    return data.filter(item =&gt; {
      return filters.every(filter =&gt; {
        return item[filter.field] === filter.value;
      });
    });
  }, [data, filters]);

  const statistics = useMemo(() =&gt; {
    console.log('Calculating statistics...');
    return {
      total: filteredData.length,
      average: filteredData.reduce((sum, item) =&gt; sum + item.value, 0) / filteredData.length,
      maximum: Math.max(...filteredData.map(item =&gt; item.value))
    };
  }, [filteredData]);

  return (
    &lt;div&gt;
      &lt;DataTable data={filteredData} /&gt;
      &lt;StatisticsPanel stats={statistics} /&gt;
    &lt;/div&gt;
  );
};
</code></pre>
<h3>3. useCallback 优化事件处理函数</h3>
<pre><code class="language-javascript">const TodoList = ({ todos, onToggle, onDelete }) =&gt; {
  const handleToggle = useCallback((id) =&gt; {
    onToggle(id);
  }, [onToggle]);

  const handleDelete = useCallback((id) =&gt; {
    onDelete(id);
  }, [onDelete]);

  return (
    &lt;ul&gt;
      {todos.map(todo =&gt; (
        &lt;TodoItem 
          key={todo.id}
          todo={todo}
          onToggle={handleToggle}
          onDelete={handleDelete}
        /&gt;
      ))}
    &lt;/ul&gt;
  );
};
</code></pre>
<h2>自定义Hook的优化</h2>
<p>今天还重构了一个自定义Hook，让代码更加简洁高效：</p>
<pre><code class="language-javascript">// 优化前
const useDataFetcher = (url) =&gt; {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() =&gt; {
    const fetchData = async () =&gt; {
      try {
        setLoading(true);
        const response = await fetch(url);
        const result = await response.json();
        setData(result);
      } catch (err) {
        setError(err);
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, [url]);

  return { data, loading, error };
};

// 优化后
const useDataFetcher = (url) =&gt; {
  const [state, setState] = useState({
    data: null,
    loading: true,
    error: null
  });

  useEffect(() =&gt; {
    let isCancelled = false;

    const fetchData = async () =&gt; {
      try {
        setState(prev =&gt; ({ ...prev, loading: true, error: null }));
        const response = await fetch(url);
        const result = await response.json();

        if (!isCancelled) {
          setState({ data: result, loading: false, error: null });
        }
      } catch (err) {
        if (!isCancelled) {
          setState({ data: null, loading: false, error: err });
        }
      }
    };

    fetchData();

    return () =&gt; {
      isCancelled = true;
    };
  }, [url]);

  return state;
};
</code></pre>
<h2>虚拟化长列表</h2>
<p>对于数据量特别大的列表，我们引入了react-window来实现虚拟滚动：</p>
<pre><code class="language-javascript">import { FixedSizeList as List } from 'react-window';

const VirtualizedList = ({ items }) =&gt; {
  const Row = ({ index, style }) =&gt; (
    &lt;div style={style}&gt;
      &lt;ListItem item={items[index]} /&gt;
    &lt;/div&gt;
  );

  return (
    &lt;List
      height={600}
      itemCount={items.length}
      itemSize={80}
      width=&quot;100%&quot;
    &gt;
      {Row}
    &lt;/List&gt;
  );
};
</code></pre>
<h2>状态管理优化</h2>
<p>发现团队在使用Redux时存在一些性能问题，今天也做了一些优化：</p>
<h3>1. 使用 useSelector 的优化</h3>
<pre><code class="language-javascript">// 不好的做法
const component = () =&gt; {
  const { user, posts, comments } = useSelector(state =&gt; state);
  // 即使只需要user，但posts和comments变化时也会重新渲染
};

// 好的做法
const component = () =&gt; {
  const user = useSelector(state =&gt; state.user);
  const posts = useSelector(state =&gt; state.posts);
  // 只有对应的数据变化时才重新渲染
};
</code></pre>
<h3>2. 使用 Reselect 创建记忆化选择器</h3>
<pre><code class="language-javascript">import { createSelector } from 'reselect';

const selectPosts = state =&gt; state.posts;
const selectFilter = state =&gt; state.filter;

const selectFilteredPosts = createSelector(
  [selectPosts, selectFilter],
  (posts, filter) =&gt; {
    return posts.filter(post =&gt; post.category === filter.category);
  }
);
</code></pre>
<h2>性能监控与测试</h2>
<h3>1. 自定义性能监控Hook</h3>
<pre><code class="language-javascript">const usePerformanceMonitor = (componentName) =&gt; {
  useEffect(() =&gt; {
    const startTime = performance.now();

    return () =&gt; {
      const endTime = performance.now();
      console.log(`${componentName} render time: ${endTime - startTime}ms`);
    };
  });
};
</code></pre>
<h3>2. 性能测试</h3>
<p>写了一些简单的性能测试来验证优化效果：</p>
<pre><code class="language-javascript">// 测试组件渲染时间
const measureRenderTime = (Component, props) =&gt; {
  const startTime = performance.now();

  render(&lt;Component {...props} /&gt;);

  const endTime = performance.now();
  return endTime - startTime;
};
</code></pre>
<h2>今天的收获</h2>
<ol>
<li><strong>工具的重要性</strong>：React DevTools Profiler真的很有用，能够直观地看到组件的渲染情况</li>
<li><strong>过度优化的陷阱</strong>：不是所有组件都需要使用memo，要根据实际情况判断</li>
<li><strong>测量的重要性</strong>：在优化前后都要进行性能测试，确保优化确实有效</li>
<li><strong>用户体验优先</strong>：技术优化最终是为了提升用户体验</li>
</ol>
<h2>遇到的问题</h2>
<p>今天也遇到了一些问题：</p>
<ol>
<li><strong>useCallback依赖项问题</strong>：一开始忘记在依赖数组中添加外部变量，导致闭包问题</li>
<li><strong>memo的比较函数</strong>：对于复杂对象prop的比较，默认的浅比较不够用，需要自定义比较函数</li>
<li><strong>内存泄漏</strong>：在useEffect中设置的定时器没有正确清理</li>
</ol>
<h2>明天的计划</h2>
<ol>
<li>继续优化剩余的页面组件</li>
<li>编写性能优化的最佳实践文档</li>
<li>与团队分享今天的优化经验</li>
<li>考虑引入一些性能监控工具到生产环境</li>
</ol>
<p>总的来说，今天的性能优化工作很有成效。通过合理使用React的优化API，我们的应用性能得到了显著提升。但也要注意不要过度优化，保持代码的可读性和可维护性同样重要。</p>
<p>React的性能优化是一个持续的过程，需要根据实际的业务场景和用户反馈不断调整和改进。希望明天能够继续保持这种状态，把剩余的优化工作完成。</p>
                </div>
            </article>
        </div>
    </main>
    
    <footer>
        <p>&copy; 2025 我的博客. All rights reserved.</p>
    </footer>
</body>
</html>