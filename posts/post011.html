<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ·±åº¦å­¦ä¹ åœ¨å‰ç«¯æ™ºèƒ½åŒ–ä¸­çš„åº”ç”¨æ¢ç´¢ - æˆ‘çš„åšå®¢</title>
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <header>
        <h1 class="slogan">è®°å½•æ€è€ƒï¼Œåˆ†äº«ç”Ÿæ´»</h1>
    </header>
    
    <main>
        <div class="container">
            <a href="../index.html" class="back-link">â† è¿”å›é¦–é¡µ</a>
            
            <article class="article-page">
                <div class="article-header">
                    <h1>æ·±åº¦å­¦ä¹ åœ¨å‰ç«¯æ™ºèƒ½åŒ–ä¸­çš„åº”ç”¨æ¢ç´¢</h1>
                    <p class="article-date">2025å¹´07æœˆ03æ—¥</p>
                </div>
                
                <div class="article-content">
                    <p><strong>Date: April 5, 2024</strong></p>
<p>éšç€äººå·¥æ™ºèƒ½æŠ€æœ¯çš„å¿«é€Ÿå‘å±•ï¼Œæ·±åº¦å­¦ä¹ ä¸å†åªæ˜¯åç«¯å’Œç®—æ³•å·¥ç¨‹å¸ˆçš„ä¸“åˆ©ã€‚å‰ç«¯å¼€å‘ä¹Ÿå¼€å§‹èå…¥æ›´å¤šæ™ºèƒ½åŒ–çš„å…ƒç´ ã€‚ä»Šå¤©æƒ³åˆ†äº«ä¸€ä¸‹æˆ‘åœ¨å‰ç«¯æ™ºèƒ½åŒ–æ–¹é¢çš„ä¸€äº›æ¢ç´¢å’Œå®è·µã€‚</p>
<h2>TensorFlow.jså…¥é—¨å®è·µ</h2>
<h3>ç¯å¢ƒæ­å»ºä¸åŸºç¡€æ¦‚å¿µ</h3>
<pre><code class="language-javascript">// å®‰è£…TensorFlow.js
// npm install @tensorflow/tfjs

import * as tf from '@tensorflow/tfjs';

// åŸºç¡€å¼ é‡æ“ä½œ
function basicTensorOperations() {
  // åˆ›å»ºå¼ é‡
  const tensor1 = tf.tensor([1, 2, 3, 4]);
  const tensor2 = tf.tensor([[1, 2], [3, 4]]);

  console.log('Tensor 1:', tensor1);
  console.log('Tensor 2:', tensor2);

  // å¼ é‡è¿ç®—
  const result = tf.add(tensor1, 10);
  console.log('Add operation:', result);

  // çŸ©é˜µä¹˜æ³•
  const matrix1 = tf.tensor2d([[1, 2], [3, 4]]);
  const matrix2 = tf.tensor2d([[5, 6], [7, 8]]);
  const product = tf.matMul(matrix1, matrix2);

  console.log('Matrix multiplication:', product);

  // æ¸…ç†å†…å­˜
  tensor1.dispose();
  tensor2.dispose();
  result.dispose();
  matrix1.dispose();
  matrix2.dispose();
  product.dispose();
}
</code></pre>
<h3>å›¾åƒåˆ†ç±»æ¨¡å‹</h3>
<pre><code class="language-javascript">// ä½¿ç”¨é¢„è®­ç»ƒçš„MobileNetæ¨¡å‹è¿›è¡Œå›¾åƒåˆ†ç±»
class ImageClassifier {
  constructor() {
    this.model = null;
    this.isLoading = false;
  }

  async loadModel() {
    if (this.isLoading) return;

    this.isLoading = true;
    try {
      // åŠ è½½é¢„è®­ç»ƒçš„MobileNetæ¨¡å‹
      this.model = await tf.loadLayersModel('https://tfhub.dev/google/tfjs-model/imagenet/mobilenet_v3_small_100_224/classification/5/default/1', {
        fromTFHub: true
      });
      console.log('Model loaded successfully');
    } catch (error) {
      console.error('Failed to load model:', error);
      // ä½¿ç”¨æœ¬åœ°å¤‡ç”¨æ¨¡å‹
      this.model = await tf.loadLayersModel('/models/mobilenet/model.json');
    } finally {
      this.isLoading = false;
    }
  }

  async classifyImage(imageElement) {
    if (!this.model) {
      throw new Error('Model not loaded');
    }

    return tf.tidy(() =&gt; {
      // é¢„å¤„ç†å›¾åƒ
      const tensor = tf.browser.fromPixels(imageElement)
        .resizeNearestNeighbor([224, 224])
        .toFloat()
        .div(tf.scalar(255.0))
        .expandDims();

      // é¢„æµ‹
      const predictions = this.model.predict(tensor);

      return predictions;
    });
  }

  async classifyImageWithLabels(imageElement) {
    const predictions = await this.classifyImage(imageElement);

    // è·å–é¢„æµ‹ç»“æœ
    const probabilities = await predictions.data();
    const topPredictions = this.getTopPredictions(probabilities, 5);

    predictions.dispose();

    return topPredictions;
  }

  getTopPredictions(probabilities, topK = 5) {
    // ImageNetç±»åˆ«æ ‡ç­¾
    const IMAGENET_CLASSES = this.loadImageNetClasses();

    const predictions = Array.from(probabilities)
      .map((probability, index) =&gt; ({
        className: IMAGENET_CLASSES[index],
        probability: probability
      }))
      .sort((a, b) =&gt; b.probability - a.probability)
      .slice(0, topK);

    return predictions;
  }

  loadImageNetClasses() {
    // è¿™é‡Œåº”è¯¥ä»æ–‡ä»¶åŠ è½½ImageNetç±»åˆ«
    // ä¸ºäº†ç®€åŒ–ï¼Œè¿™é‡Œåªè¿”å›ä¸€äº›ç¤ºä¾‹ç±»åˆ«
    return [
      'Egyptian cat', 'tabby cat', 'tiger cat', 'Persian cat',
      'Siamese cat', 'golden retriever', 'Labrador retriever',
      'German shepherd', 'beagle', 'border collie'
      // ... æ›´å¤šç±»åˆ«
    ];
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const classifier = new ImageClassifier();

async function setupImageClassification() {
  await classifier.loadModel();

  const fileInput = document.getElementById('imageInput');
  const preview = document.getElementById('imagePreview');
  const results = document.getElementById('results');

  fileInput.addEventListener('change', async (event) =&gt; {
    const file = event.target.files[0];
    if (!file) return;

    // æ˜¾ç¤ºå›¾åƒé¢„è§ˆ
    const reader = new FileReader();
    reader.onload = async (e) =&gt; {
      preview.src = e.target.result;
      preview.style.display = 'block';

      // ç­‰å¾…å›¾åƒåŠ è½½å®Œæˆ
      preview.onload = async () =&gt; {
        try {
          const predictions = await classifier.classifyImageWithLabels(preview);
          displayResults(predictions);
        } catch (error) {
          console.error('Classification failed:', error);
        }
      };
    };
    reader.readAsDataURL(file);
  });

  function displayResults(predictions) {
    results.innerHTML = '&lt;h3&gt;é¢„æµ‹ç»“æœ:&lt;/h3&gt;';
    predictions.forEach((prediction, index) =&gt; {
      const percentage = (prediction.probability * 100).toFixed(2);
      results.innerHTML += `
        &lt;div class=&quot;prediction&quot;&gt;
          ${index + 1}. ${prediction.className}: ${percentage}%
        &lt;/div&gt;
      `;
    });
  }
}
</code></pre>
<h2>è‡ªç„¶è¯­è¨€å¤„ç†åº”ç”¨</h2>
<h3>æƒ…æ„Ÿåˆ†ææ¨¡å‹</h3>
<pre><code class="language-javascript">// ç®€å•çš„æƒ…æ„Ÿåˆ†æå®ç°
class SentimentAnalyzer {
  constructor() {
    this.model = null;
    this.tokenizer = null;
    this.maxLength = 100;
  }

  async loadModel() {
    // åŠ è½½é¢„è®­ç»ƒçš„æƒ…æ„Ÿåˆ†ææ¨¡å‹
    this.model = await tf.loadLayersModel('/models/sentiment/model.json');

    // åŠ è½½è¯æ±‡è¡¨
    const vocab = await fetch('/models/sentiment/vocab.json').then(r =&gt; r.json());
    this.tokenizer = new SimpleTokenizer(vocab);
  }

  async analyzeSentiment(text) {
    if (!this.model || !this.tokenizer) {
      throw new Error('Model not loaded');
    }

    return tf.tidy(() =&gt; {
      // æ–‡æœ¬é¢„å¤„ç†
      const tokens = this.tokenizer.tokenize(text);
      const paddedTokens = this.padSequence(tokens, this.maxLength);

      // è½¬æ¢ä¸ºå¼ é‡
      const inputTensor = tf.tensor2d([paddedTokens], [1, this.maxLength]);

      // é¢„æµ‹
      const prediction = this.model.predict(inputTensor);

      return prediction;
    });
  }

  async getSentimentScore(text) {
    const prediction = await this.analyzeSentiment(text);
    const score = await prediction.data();

    prediction.dispose();

    return {
      positive: score[0],
      negative: 1 - score[0],
      label: score[0] &gt; 0.5 ? 'positive' : 'negative',
      confidence: Math.abs(score[0] - 0.5) * 2
    };
  }

  padSequence(sequence, maxLength) {
    if (sequence.length &gt;= maxLength) {
      return sequence.slice(0, maxLength);
    }

    const padded = [...sequence];
    while (padded.length &lt; maxLength) {
      padded.push(0); // 0æ˜¯padding token
    }

    return padded;
  }
}

// ç®€å•åˆ†è¯å™¨
class SimpleTokenizer {
  constructor(vocab) {
    this.vocab = vocab;
    this.wordToIndex = new Map(Object.entries(vocab));
    this.unknownToken = this.wordToIndex.get('&lt;UNK&gt;') || 1;
  }

  tokenize(text) {
    // ç®€å•çš„åˆ†è¯å’Œæ ‡è®°åŒ–
    const words = text.toLowerCase()
      .replace(/[^\w\s]/g, ' ')
      .split(/\s+/)
      .filter(word =&gt; word.length &gt; 0);

    return words.map(word =&gt; this.wordToIndex.get(word) || this.unknownToken);
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const sentimentAnalyzer = new SentimentAnalyzer();

async function setupSentimentAnalysis() {
  await sentimentAnalyzer.loadModel();

  const textInput = document.getElementById('textInput');
  const analyzeButton = document.getElementById('analyzeButton');
  const sentimentResult = document.getElementById('sentimentResult');

  analyzeButton.addEventListener('click', async () =&gt; {
    const text = textInput.value.trim();
    if (!text) return;

    try {
      const result = await sentimentAnalyzer.getSentimentScore(text);
      displaySentimentResult(result);
    } catch (error) {
      console.error('Sentiment analysis failed:', error);
    }
  });

  function displaySentimentResult(result) {
    const confidence = (result.confidence * 100).toFixed(1);
    const emoji = result.label === 'positive' ? 'ğŸ˜Š' : 'ğŸ˜';

    sentimentResult.innerHTML = `
      &lt;div class=&quot;sentiment-result&quot;&gt;
        &lt;h3&gt;æƒ…æ„Ÿåˆ†æç»“æœ ${emoji}&lt;/h3&gt;
        &lt;p&gt;æƒ…æ„Ÿå€¾å‘: ${result.label === 'positive' ? 'ç§¯æ' : 'æ¶ˆæ'}&lt;/p&gt;
        &lt;p&gt;ç½®ä¿¡åº¦: ${confidence}%&lt;/p&gt;
        &lt;div class=&quot;sentiment-bar&quot;&gt;
          &lt;div class=&quot;positive-bar&quot; style=&quot;width: ${result.positive * 100}%&quot;&gt;&lt;/div&gt;
          &lt;div class=&quot;negative-bar&quot; style=&quot;width: ${result.negative * 100}%&quot;&gt;&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    `;
  }
}
</code></pre>
<h2>æ¨èç³»ç»Ÿå®ç°</h2>
<h3>ååŒè¿‡æ»¤æ¨è</h3>
<pre><code class="language-javascript">// ç®€å•çš„ååŒè¿‡æ»¤æ¨èç³»ç»Ÿ
class CollaborativeFilteringRecommender {
  constructor() {
    this.userItemMatrix = null;
    this.userSimilarity = null;
    this.itemSimilarity = null;
  }

  // æ„å»ºç”¨æˆ·-ç‰©å“çŸ©é˜µ
  buildUserItemMatrix(ratings) {
    const users = [...new Set(ratings.map(r =&gt; r.userId))];
    const items = [...new Set(ratings.map(r =&gt; r.itemId))];

    const matrix = tf.zeros([users.length, items.length]);

    const userIndexMap = new Map(users.map((id, index) =&gt; [id, index]));
    const itemIndexMap = new Map(items.map((id, index) =&gt; [id, index]));

    // å¡«å……è¯„åˆ†çŸ©é˜µ
    ratings.forEach(rating =&gt; {
      const userIndex = userIndexMap.get(rating.userId);
      const itemIndex = itemIndexMap.get(rating.itemId);
      matrix.bufferSync().set(rating.rating, userIndex, itemIndex);
    });

    this.userItemMatrix = matrix;
    this.userIndexMap = userIndexMap;
    this.itemIndexMap = itemIndexMap;
    this.users = users;
    this.items = items;

    return matrix;
  }

  // è®¡ç®—ç”¨æˆ·ç›¸ä¼¼åº¦
  calculateUserSimilarity() {
    return tf.tidy(() =&gt; {
      // ä½¿ç”¨ä½™å¼¦ç›¸ä¼¼åº¦
      const normalizedMatrix = tf.div(
        this.userItemMatrix,
        tf.norm(this.userItemMatrix, 'euclidean', 1, true)
      );

      const similarity = tf.matMul(normalizedMatrix, normalizedMatrix, false, true);
      this.userSimilarity = similarity;

      return similarity;
    });
  }

  // åŸºäºç”¨æˆ·çš„ååŒè¿‡æ»¤æ¨è
  async recommendForUser(userId, topK = 10) {
    if (!this.userSimilarity) {
      this.calculateUserSimilarity();
    }

    const userIndex = this.userIndexMap.get(userId);
    if (userIndex === undefined) {
      throw new Error('User not found');
    }

    return tf.tidy(() =&gt; {
      // è·å–ç”¨æˆ·ç›¸ä¼¼åº¦
      const userSim = this.userSimilarity.slice([userIndex, 0], [1, -1]).squeeze();

      // è·å–ç”¨æˆ·è¯„åˆ†
      const userRatings = this.userItemMatrix.slice([userIndex, 0], [1, -1]).squeeze();

      // è®¡ç®—é¢„æµ‹è¯„åˆ†
      const predictions = tf.matMul(userSim.expandDims(0), this.userItemMatrix).squeeze();

      // æ’é™¤å·²è¯„åˆ†çš„ç‰©å“
      const mask = tf.equal(userRatings, 0);
      const filteredPredictions = tf.where(mask, predictions, tf.zerosLike(predictions));

      // è·å–top-Kæ¨è
      const topIndices = tf.topk(filteredPredictions, topK).indices;

      return topIndices;
    });
  }

  // è·å–æ¨èç»“æœ
  async getRecommendations(userId, topK = 10) {
    const topIndices = await this.recommendForUser(userId, topK);
    const indices = await topIndices.data();

    const recommendations = Array.from(indices).map(index =&gt; ({
      itemId: this.items[index],
      score: Math.random() // è¿™é‡Œåº”è¯¥æ˜¯å®é™…çš„é¢„æµ‹åˆ†æ•°
    }));

    topIndices.dispose();

    return recommendations;
  }
}

// çŸ©é˜µåˆ†è§£æ¨èç³»ç»Ÿ
class MatrixFactorizationRecommender {
  constructor(numFactors = 50, learningRate = 0.01, regularization = 0.01) {
    this.numFactors = numFactors;
    this.learningRate = learningRate;
    this.regularization = regularization;
    this.userEmbeddings = null;
    this.itemEmbeddings = null;
  }

  async train(ratings, numEpochs = 100) {
    const users = [...new Set(ratings.map(r =&gt; r.userId))];
    const items = [...new Set(ratings.map(r =&gt; r.itemId))];

    // åˆå§‹åŒ–åµŒå…¥çŸ©é˜µ
    this.userEmbeddings = tf.randomNormal([users.length, this.numFactors], 0, 0.1);
    this.itemEmbeddings = tf.randomNormal([items.length, this.numFactors], 0, 0.1);

    const userIndexMap = new Map(users.map((id, index) =&gt; [id, index]));
    const itemIndexMap = new Map(items.map((id, index) =&gt; [id, index]));

    // å‡†å¤‡è®­ç»ƒæ•°æ®
    const trainingData = ratings.map(rating =&gt; ({
      userIndex: userIndexMap.get(rating.userId),
      itemIndex: itemIndexMap.get(rating.itemId),
      rating: rating.rating
    }));

    // è®­ç»ƒå¾ªç¯
    for (let epoch = 0; epoch &lt; numEpochs; epoch++) {
      let totalLoss = 0;

      for (const sample of trainingData) {
        const loss = await this.trainStep(sample);
        totalLoss += loss;
      }

      if (epoch % 10 === 0) {
        console.log(`Epoch ${epoch}, Loss: ${totalLoss / trainingData.length}`);
      }
    }

    this.userIndexMap = userIndexMap;
    this.itemIndexMap = itemIndexMap;
    this.users = users;
    this.items = items;
  }

  async trainStep(sample) {
    return tf.tidy(() =&gt; {
      const userEmb = this.userEmbeddings.slice([sample.userIndex, 0], [1, -1]);
      const itemEmb = this.itemEmbeddings.slice([sample.itemIndex, 0], [1, -1]);

      // é¢„æµ‹è¯„åˆ†
      const prediction = tf.sum(tf.mul(userEmb, itemEmb));

      // è®¡ç®—æŸå¤±
      const error = tf.sub(sample.rating, prediction);
      const loss = tf.add(
        tf.square(error),
        tf.mul(this.regularization, tf.add(tf.sum(tf.square(userEmb)), tf.sum(tf.square(itemEmb))))
      );

      // è®¡ç®—æ¢¯åº¦
      const userGrad = tf.add(
        tf.mul(tf.mul(error, -1), itemEmb),
        tf.mul(this.regularization * 2, userEmb)
      );
      const itemGrad = tf.add(
        tf.mul(tf.mul(error, -1), userEmb),
        tf.mul(this.regularization * 2, itemEmb)
      );

      // æ›´æ–°åµŒå…¥
      const userUpdate = tf.mul(userGrad, this.learningRate);
      const itemUpdate = tf.mul(itemGrad, this.learningRate);

      this.userEmbeddings = this.userEmbeddings.sub(userUpdate.expandDims(0));
      this.itemEmbeddings = this.itemEmbeddings.sub(itemUpdate.expandDims(0));

      return loss.dataSync()[0];
    });
  }

  async predict(userId, itemId) {
    const userIndex = this.userIndexMap.get(userId);
    const itemIndex = this.itemIndexMap.get(itemId);

    if (userIndex === undefined || itemIndex === undefined) {
      return 0;
    }

    return tf.tidy(() =&gt; {
      const userEmb = this.userEmbeddings.slice([userIndex, 0], [1, -1]);
      const itemEmb = this.itemEmbeddings.slice([itemIndex, 0], [1, -1]);

      const prediction = tf.sum(tf.mul(userEmb, itemEmb));
      return prediction.dataSync()[0];
    });
  }
}
</code></pre>
<h2>å®æ—¶äººè„¸æ£€æµ‹</h2>
<pre><code class="language-javascript">// ä½¿ç”¨MediaPipeè¿›è¡Œå®æ—¶äººè„¸æ£€æµ‹
class FaceDetector {
  constructor() {
    this.model = null;
    this.video = null;
    this.canvas = null;
    this.ctx = null;
  }

  async loadModel() {
    // åŠ è½½BlazeFaceæ¨¡å‹
    this.model = await tf.loadLayersModel('https://tfhub.dev/mediapipe/tfjs-model/face_detection/short/1');
  }

  async setupCamera() {
    this.video = document.getElementById('video');
    this.canvas = document.getElementById('canvas');
    this.ctx = this.canvas.getContext('2d');

    const stream = await navigator.mediaDevices.getUserMedia({
      video: { width: 640, height: 480 }
    });

    this.video.srcObject = stream;

    return new Promise((resolve) =&gt; {
      this.video.onloadedmetadata = () =&gt; {
        this.canvas.width = this.video.videoWidth;
        this.canvas.height = this.video.videoHeight;
        resolve();
      };
    });
  }

  async detectFaces() {
    if (!this.model || !this.video) return;

    return tf.tidy(() =&gt; {
      const img = tf.browser.fromPixels(this.video);
      const resized = tf.image.resizeBilinear(img, [128, 128]);
      const normalized = resized.div(255.0);
      const batched = normalized.expandDims(0);

      const predictions = this.model.predict(batched);
      return predictions;
    });
  }

  async startDetection() {
    await this.loadModel();
    await this.setupCamera();

    this.video.play();
    this.detectLoop();
  }

  async detectLoop() {
    try {
      const predictions = await this.detectFaces();

      if (predictions) {
        await this.drawDetections(predictions);
        predictions.dispose();
      }
    } catch (error) {
      console.error('Detection error:', error);
    }

    requestAnimationFrame(() =&gt; this.detectLoop());
  }

  async drawDetections(predictions) {
    // æ¸…é™¤ç”»å¸ƒ
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

    // ç»˜åˆ¶è§†é¢‘å¸§
    this.ctx.drawImage(this.video, 0, 0, this.canvas.width, this.canvas.height);

    // è·å–æ£€æµ‹ç»“æœ
    const detections = await predictions.data();

    // ç»˜åˆ¶è¾¹ç•Œæ¡†
    this.ctx.strokeStyle = '#00FF00';
    this.ctx.lineWidth = 2;

    // è¿™é‡Œéœ€è¦æ ¹æ®å…·ä½“æ¨¡å‹è¾“å‡ºæ ¼å¼æ¥è§£ææ£€æµ‹ç»“æœ
    // ç¤ºä¾‹ä»£ç ï¼Œå®é™…éœ€è¦æ ¹æ®æ¨¡å‹è°ƒæ•´
    for (let i = 0; i &lt; detections.length; i += 6) {
      const confidence = detections[i + 4];

      if (confidence &gt; 0.5) {
        const x = detections[i] * this.canvas.width;
        const y = detections[i + 1] * this.canvas.height;
        const width = detections[i + 2] * this.canvas.width;
        const height = detections[i + 3] * this.canvas.height;

        this.ctx.strokeRect(x, y, width, height);

        // ç»˜åˆ¶ç½®ä¿¡åº¦
        this.ctx.fillStyle = '#00FF00';
        this.ctx.font = '16px Arial';
        this.ctx.fillText(`${(confidence * 100).toFixed(1)}%`, x, y - 5);
      }
    }
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const faceDetector = new FaceDetector();

document.getElementById('startButton').addEventListener('click', () =&gt; {
  faceDetector.startDetection();
});
</code></pre>
<h2>æ€§èƒ½ä¼˜åŒ–ä¸æœ€ä½³å®è·µ</h2>
<h3>æ¨¡å‹ä¼˜åŒ–</h3>
<pre><code class="language-javascript">// æ¨¡å‹é‡åŒ–å’Œä¼˜åŒ–
class ModelOptimizer {
  static async quantizeModel(model) {
    // é‡åŒ–æ¨¡å‹ä»¥å‡å°‘å¤§å°å’Œæé«˜é€Ÿåº¦
    const quantizedModel = await tf.quantization.quantize(model, {
      weightQuantizationBytes: 1, // ä½¿ç”¨8ä½é‡åŒ–
      activationQuantizationBytes: 2
    });

    return quantizedModel;
  }

  static async pruneModel(model, sparsity = 0.5) {
    // æ¨¡å‹å‰ªæ
    const prunedModel = tf.prune.prune(model, {
      pruningSchedule: tf.prune.sparsitySchedule.constantSparsity(sparsity)
    });

    return prunedModel;
  }

  static setupMemoryOptimization() {
    // è®¾ç½®å†…å­˜å¢é•¿ç­–ç•¥
    tf.env().set('WEBGL_DELETE_TEXTURE_THRESHOLD', 0);
    tf.env().set('WEBGL_FORCE_F16_TEXTURES', true);

    // å®šæœŸæ¸…ç†å†…å­˜
    setInterval(() =&gt; {
      const memInfo = tf.memory();
      console.log('Memory usage:', memInfo);

      if (memInfo.numTensors &gt; 100) {
        tf.disposeVariables();
      }
    }, 5000);
  }
}

// æ‰¹å¤„ç†å’Œç¼“å­˜ä¼˜åŒ–
class InferenceOptimizer {
  constructor() {
    this.batchSize = 32;
    this.cache = new Map();
  }

  async batchPredict(model, inputs) {
    const batches = this.createBatches(inputs, this.batchSize);
    const results = [];

    for (const batch of batches) {
      const batchTensor = tf.stack(batch);
      const prediction = model.predict(batchTensor);

      const batchResults = await prediction.data();
      results.push(...batchResults);

      batchTensor.dispose();
      prediction.dispose();
    }

    return results;
  }

  createBatches(array, batchSize) {
    const batches = [];
    for (let i = 0; i &lt; array.length; i += batchSize) {
      batches.push(array.slice(i, i + batchSize));
    }
    return batches;
  }

  async cachedPredict(model, input, cacheKey) {
    if (this.cache.has(cacheKey)) {
      return this.cache.get(cacheKey);
    }

    const prediction = await model.predict(input);
    const result = await prediction.data();

    this.cache.set(cacheKey, result);
    prediction.dispose();

    return result;
  }
}
</code></pre>
<h2>æ€»ç»“ä¸å±•æœ›</h2>
<p>å‰ç«¯æ™ºèƒ½åŒ–æ˜¯ä¸€ä¸ªå……æ»¡æœºé‡çš„é¢†åŸŸï¼Œé€šè¿‡TensorFlow.jsç­‰å·¥å…·ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨æµè§ˆå™¨ä¸­ç›´æ¥è¿è¡Œæœºå™¨å­¦ä¹ æ¨¡å‹ï¼Œä¸ºç”¨æˆ·æä¾›æ›´æ™ºèƒ½çš„äº¤äº’ä½“éªŒã€‚</p>
<h3>ä¸»è¦æ”¶è·</h3>
<ol>
<li><strong>æŠ€æœ¯å¯è¡Œæ€§</strong>ï¼šåœ¨æµè§ˆå™¨ä¸­è¿è¡Œæ·±åº¦å­¦ä¹ æ¨¡å‹å·²ç»æˆä¸ºç°å®</li>
<li><strong>æ€§èƒ½è€ƒè™‘</strong>ï¼šéœ€è¦åœ¨æ¨¡å‹å¤æ‚åº¦å’Œè¿è¡Œæ•ˆç‡ä¹‹é—´æ‰¾åˆ°å¹³è¡¡</li>
<li><strong>ç”¨æˆ·ä½“éªŒ</strong>ï¼šæ™ºèƒ½åŠŸèƒ½åº”è¯¥æ— ç¼é›†æˆåˆ°ç”¨æˆ·ç•Œé¢ä¸­</li>
<li><strong>éšç§ä¿æŠ¤</strong>ï¼šå®¢æˆ·ç«¯æ¨ç†é¿å…äº†æ•°æ®ä¸Šä¼ åˆ°æœåŠ¡å™¨</li>
</ol>
<h3>æŒ‘æˆ˜ä¸é™åˆ¶</h3>
<ol>
<li><strong>è®¡ç®—èµ„æºé™åˆ¶</strong>ï¼šæµè§ˆå™¨çš„è®¡ç®—èƒ½åŠ›ç›¸å¯¹æœ‰é™</li>
<li><strong>æ¨¡å‹å¤§å°</strong>ï¼šå¤§å‹æ¨¡å‹çš„åŠ è½½æ—¶é—´å’Œå†…å­˜å ç”¨</li>
<li><strong>å…¼å®¹æ€§é—®é¢˜</strong>ï¼šä¸åŒæµè§ˆå™¨çš„æ”¯æŒç¨‹åº¦å·®å¼‚</li>
<li><strong>è°ƒè¯•å›°éš¾</strong>ï¼šå‰ç«¯AIåº”ç”¨çš„è°ƒè¯•ç›¸å¯¹å¤æ‚</li>
</ol>
<h3>æœªæ¥å‘å±•æ–¹å‘</h3>
<ol>
<li><strong>WebGPUæ”¯æŒ</strong>ï¼šæ›´å¼ºå¤§çš„GPUè®¡ç®—èƒ½åŠ›</li>
<li><strong>æ¨¡å‹å‹ç¼©æŠ€æœ¯</strong>ï¼šæ›´å°ã€æ›´å¿«çš„æ¨¡å‹</li>
<li><strong>è¾¹ç¼˜è®¡ç®—é›†æˆ</strong>ï¼šç»“åˆè¾¹ç¼˜è®¾å¤‡çš„è®¡ç®—èƒ½åŠ›</li>
<li><strong>æ ‡å‡†åŒ–å‘å±•</strong>ï¼šW3Cç­‰ç»„ç»‡çš„æ ‡å‡†åŒ–å·¥ä½œ</li>
</ol>
<p>å‰ç«¯æ™ºèƒ½åŒ–æ­£åœ¨æ”¹å˜æˆ‘ä»¬æ„å»ºWebåº”ç”¨çš„æ–¹å¼ï¼Œè™½ç„¶è¿˜æœ‰å¾ˆå¤šæŒ‘æˆ˜éœ€è¦å…‹æœï¼Œä½†è¿™ä¸ªé¢†åŸŸçš„å‘å±•å‰æ™¯éå¸¸å¹¿é˜”ã€‚ä½œä¸ºå‰ç«¯å¼€å‘è€…ï¼ŒæŒæ¡è¿™äº›æŠ€èƒ½å°†ä¸ºæˆ‘ä»¬çš„èŒä¸šå‘å±•å¸¦æ¥æ–°çš„æœºé‡ã€‚</p>
                </div>
            </article>
        </div>
    </main>
    
    <footer>
        <p>&copy; 2025 æˆ‘çš„åšå®¢. All rights reserved.</p>
    </footer>
</body>
</html>