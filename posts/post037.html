<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä»£ç å®¡æŸ¥æ–‡åŒ–å»ºè®¾ï¼šä»ä¸ªäººæŠ€èƒ½åˆ°å›¢é˜Ÿæ ‡å‡† - æˆ‘çš„åšå®¢</title>
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <header>
        <h1 class="slogan">è®°å½•æ€è€ƒï¼Œåˆ†äº«ç”Ÿæ´»</h1>
    </header>
    
    <main>
        <div class="container">
            <a href="../index.html" class="back-link">â† è¿”å›é¦–é¡µ</a>
            
            <article class="article-page">
                <div class="article-header">
                    <h1>ä»£ç å®¡æŸ¥æ–‡åŒ–å»ºè®¾ï¼šä»ä¸ªäººæŠ€èƒ½åˆ°å›¢é˜Ÿæ ‡å‡†</h1>
                    <p class="article-date">2024å¹´06æœˆ10æ—¥</p>
                </div>
                
                <div class="article-content">
                    <hr />
<p>title: "ä»£ç å®¡æŸ¥æ–‡åŒ–å»ºè®¾ï¼šä»ä¸ªäººæŠ€èƒ½åˆ°å›¢é˜Ÿæ ‡å‡†"<br />
date: "2024-06-10"<br />
tags: ["ä»£ç å®¡æŸ¥", "å›¢é˜Ÿæ–‡åŒ–", "æœ€ä½³å®è·µ", "ä»£ç è´¨é‡"]</p>
<hr />
<h1>ä»£ç å®¡æŸ¥æ–‡åŒ–å»ºè®¾ï¼šä»ä¸ªäººæŠ€èƒ½åˆ°å›¢é˜Ÿæ ‡å‡†</h1>
<p>ä¸€å¹´å‰ï¼Œå½“æˆ‘å¼€å§‹åœ¨æ–°å…¬å¸æ‹…ä»»æŠ€æœ¯è´Ÿè´£äººæ—¶ï¼Œå‘ç°å›¢é˜Ÿçš„ä»£ç å®¡æŸ¥æµç¨‹å½¢åŒè™šè®¾ã€‚å¤§éƒ¨åˆ†PRéƒ½æ˜¯è‰è‰é€šè¿‡ï¼Œç¼ºä¹å®è´¨æ€§çš„åé¦ˆã€‚ç»è¿‡ä¸€å¹´çš„åŠªåŠ›ï¼Œæˆ‘ä»¬å»ºç«‹äº†ä¸€å¥—å®Œå–„çš„ä»£ç å®¡æŸ¥æ–‡åŒ–ï¼Œä¸ä»…æé«˜äº†ä»£ç è´¨é‡ï¼Œæ›´é‡è¦çš„æ˜¯ä¿ƒè¿›äº†å›¢é˜Ÿçš„æŠ€æœ¯æˆé•¿ã€‚</p>
<h2>ç°çŠ¶åˆ†æï¼šé—®é¢˜åœ¨å“ªé‡Œ</h2>
<h3>åˆå§‹çŠ¶æ€è¯„ä¼°</h3>
<p>å½“æ—¶çš„ä»£ç å®¡æŸ¥æµç¨‹å­˜åœ¨ä»¥ä¸‹é—®é¢˜ï¼š</p>
<pre><code class="language-javascript">// å…¸å‹çš„é—®é¢˜ä»£ç ç¤ºä¾‹
// 1. ç¼ºä¹æ–‡æ¡£å’Œæ³¨é‡Š
function processData(data) {
  var result = [];
  for (var i = 0; i &lt; data.length; i++) {
    if (data[i].status == &quot;active&quot;) {
      result.push(data[i]);
    }
  }
  return result;
}

// 2. æ²¡æœ‰é”™è¯¯å¤„ç†
async function fetchUserData(userId) {
  const response = await fetch(`/api/users/${userId}`);
  const userData = await response.json();
  return userData.profile;
}

// 3. ç¡¬ç¼–ç å’Œé­”æ³•æ•°å­—
const MAX_RETRIES = 3;  // æ²¡æœ‰è¯´æ˜ä¸ºä»€ä¹ˆæ˜¯3
const TIMEOUT = 5000;   // æ²¡æœ‰å•ä½è¯´æ˜

// 4. ç¼ºä¹ç±»å‹æ£€æŸ¥
function calculateTotal(items) {
  return items.reduce((sum, item) =&gt; sum + item.price, 0);
}
</code></pre>
<h3>å›¢é˜Ÿåé¦ˆæ”¶é›†</h3>
<p>æˆ‘é¦–å…ˆé€šè¿‡åŒ¿åè°ƒæŸ¥äº†è§£å›¢é˜Ÿå¯¹ä»£ç å®¡æŸ¥çš„çœ‹æ³•ï¼š</p>
<pre><code class="language-javascript">// è°ƒæŸ¥ç»“æœç»Ÿè®¡
const surveyResults = {
  participation: {
    regularlyReview: 30,    // 30%çš„äººç»å¸¸åšä»£ç å®¡æŸ¥
    occasionallyReview: 45, // 45%çš„äººå¶å°”åš
    rarelyReview: 25       // 25%çš„äººå¾ˆå°‘åš
  },
  concerns: [
    &quot;ä¸çŸ¥é“åº”è¯¥çœ‹ä»€ä¹ˆ&quot;,
    &quot;æ‹…å¿ƒå¾—ç½ªåŒäº‹&quot;,
    &quot;æ—¶é—´å‹åŠ›å¤ªå¤§&quot;,
    &quot;ç¼ºä¹æŠ€æœ¯æ·±åº¦&quot;,
    &quot;æ²¡æœ‰æ˜ç¡®çš„æ ‡å‡†&quot;
  ],
  painPoints: {
    tooLong: 60,      // 60%è§‰å¾—å®¡æŸ¥æ—¶é—´å¤ªé•¿
    lackFeedback: 70, // 70%è§‰å¾—ç¼ºä¹æœ‰ä»·å€¼çš„åé¦ˆ
    conflictAvoidance: 55 // 55%é¿å…æå‡ºäº‰è®®æ€§æ„è§
  }
};
</code></pre>
<h2>å»ºç«‹ä»£ç å®¡æŸ¥æ ‡å‡†</h2>
<h3>åˆ¶å®šå®¡æŸ¥æ¸…å•</h3>
<p>æˆ‘ä»¬åˆ¶å®šäº†ä¸€ä»½è¯¦ç»†çš„ä»£ç å®¡æŸ¥æ¸…å•ï¼š</p>
<pre><code class="language-markdown"># ä»£ç å®¡æŸ¥æ¸…å•

## 1. åŠŸèƒ½æ€§ (Functionality)
- [ ] ä»£ç æ˜¯å¦æŒ‰ç…§é¢„æœŸå·¥ä½œï¼Ÿ
- [ ] æ˜¯å¦æœ‰å……åˆ†çš„æµ‹è¯•è¦†ç›–ï¼Ÿ
- [ ] è¾¹ç•Œæ¡ä»¶æ˜¯å¦è¢«æ­£ç¡®å¤„ç†ï¼Ÿ
- [ ] é”™è¯¯å¤„ç†æ˜¯å¦å®Œæ•´ï¼Ÿ

## 2. å¯è¯»æ€§ (Readability)
- [ ] ä»£ç æ˜¯å¦æ˜“äºç†è§£ï¼Ÿ
- [ ] å‘½åæ˜¯å¦æ¸…æ™°æ˜ç¡®ï¼Ÿ
- [ ] æ³¨é‡Šæ˜¯å¦å¿…è¦ä¸”æœ‰å¸®åŠ©ï¼Ÿ
- [ ] ä»£ç ç»“æ„æ˜¯å¦åˆç†ï¼Ÿ

## 3. æ€§èƒ½ (Performance)
- [ ] æ˜¯å¦å­˜åœ¨æ˜æ˜¾çš„æ€§èƒ½é—®é¢˜ï¼Ÿ
- [ ] ç®—æ³•é€‰æ‹©æ˜¯å¦åˆç†ï¼Ÿ
- [ ] å†…å­˜ä½¿ç”¨æ˜¯å¦é«˜æ•ˆï¼Ÿ
- [ ] æ˜¯å¦æœ‰ä¸å¿…è¦çš„è®¡ç®—ï¼Ÿ

## 4. å®‰å…¨æ€§ (Security)
- [ ] è¾“å…¥éªŒè¯æ˜¯å¦å……åˆ†ï¼Ÿ
- [ ] æ˜¯å¦å­˜åœ¨SQLæ³¨å…¥é£é™©ï¼Ÿ
- [ ] æ•æ„Ÿä¿¡æ¯æ˜¯å¦è¢«æ­£ç¡®å¤„ç†ï¼Ÿ
- [ ] æƒé™æ£€æŸ¥æ˜¯å¦å®Œæ•´ï¼Ÿ

## 5. å¯ç»´æŠ¤æ€§ (Maintainability)
- [ ] ä»£ç æ˜¯å¦éµå¾ªå›¢é˜Ÿçº¦å®šï¼Ÿ
- [ ] æ˜¯å¦å®¹æ˜“æ‰©å±•å’Œä¿®æ”¹ï¼Ÿ
- [ ] ä¾èµ–å…³ç³»æ˜¯å¦æ¸…æ™°ï¼Ÿ
- [ ] é…ç½®æ˜¯å¦å¤–éƒ¨åŒ–ï¼Ÿ
</code></pre>
<h3>ä»£ç æ ‡å‡†è§„èŒƒ</h3>
<p>æˆ‘ä»¬å»ºç«‹äº†è¯¦ç»†çš„ä»£ç æ ‡å‡†ï¼š</p>
<pre><code class="language-javascript">// ä»£ç æ ‡å‡†ç¤ºä¾‹

// 1. å‡½æ•°å‘½åå’Œæ–‡æ¡£
/**
 * è¿‡æ»¤æ´»è·ƒç”¨æˆ·æ•°æ®
 * @param {Array&lt;User&gt;} users - ç”¨æˆ·æ•°ç»„
 * @param {Object} options - è¿‡æ»¤é€‰é¡¹
 * @param {boolean} options.includeInactive - æ˜¯å¦åŒ…å«éæ´»è·ƒç”¨æˆ·
 * @returns {Array&lt;User&gt;} è¿‡æ»¤åçš„ç”¨æˆ·æ•°ç»„
 */
function filterActiveUsers(users, options = {}) {
  if (!Array.isArray(users)) {
    throw new TypeError('Users must be an array');
  }

  const { includeInactive = false } = options;

  return users.filter(user =&gt; {
    if (!user || typeof user !== 'object') {
      return false;
    }

    return includeInactive || user.status === 'active';
  });
}

// 2. é”™è¯¯å¤„ç†æ ‡å‡†
async function fetchUserData(userId) {
  try {
    validateUserId(userId);

    const response = await fetch(`/api/users/${userId}`, {
      timeout: REQUEST_TIMEOUT,
      headers: {
        'Content-Type': 'application/json'
      }
    });

    if (!response.ok) {
      throw new Error(`HTTP Error: ${response.status} ${response.statusText}`);
    }

    const userData = await response.json();

    if (!userData || !userData.profile) {
      throw new Error('Invalid user data structure');
    }

    return userData.profile;

  } catch (error) {
    logger.error('Failed to fetch user data', {
      userId,
      error: error.message,
      stack: error.stack
    });

    throw new Error(`Unable to fetch user data: ${error.message}`);
  }
}

// 3. å¸¸é‡å’Œé…ç½®ç®¡ç†
const CONFIG = {
  API: {
    REQUEST_TIMEOUT: 5000, // 5ç§’è¶…æ—¶
    MAX_RETRIES: 3,        // æœ€å¤§é‡è¯•æ¬¡æ•°
    RETRY_DELAY: 1000      // é‡è¯•å»¶è¿Ÿ(æ¯«ç§’)
  },

  USER: {
    ACTIVE_STATUS: 'active',
    INACTIVE_STATUS: 'inactive'
  }
};

// 4. ç±»å‹æ£€æŸ¥å’ŒéªŒè¯
function validateUserId(userId) {
  if (!userId) {
    throw new Error('User ID is required');
  }

  if (typeof userId !== 'string' &amp;&amp; typeof userId !== 'number') {
    throw new TypeError('User ID must be a string or number');
  }

  if (typeof userId === 'string' &amp;&amp; userId.trim().length === 0) {
    throw new Error('User ID cannot be empty');
  }

  return true;
}
</code></pre>
<h2>ä»£ç å®¡æŸ¥æµç¨‹è®¾è®¡</h2>
<h3>å¤šçº§å®¡æŸ¥æœºåˆ¶</h3>
<p>æˆ‘ä»¬è®¾è®¡äº†åˆ†å±‚çš„å®¡æŸ¥æœºåˆ¶ï¼š</p>
<pre><code class="language-javascript">// å®¡æŸ¥æµç¨‹é…ç½®
const reviewProcess = {
  levels: [
    {
      name: 'automated',
      description: 'è‡ªåŠ¨åŒ–æ£€æŸ¥',
      required: true,
      checks: [
        'linting',
        'unit-tests',
        'security-scan',
        'coverage-check'
      ]
    },
    {
      name: 'peer-review',
      description: 'åŒçº§å®¡æŸ¥',
      required: true,
      reviewers: {
        count: 1,
        criteria: 'same-team'
      }
    },
    {
      name: 'senior-review',
      description: 'é«˜çº§å®¡æŸ¥',
      required: false, // æ ¹æ®å˜æ›´å¤§å°å†³å®š
      trigger: {
        linesChanged: 500,
        filesChanged: 10,
        criticalPaths: ['auth/', 'payment/', 'security/']
      },
      reviewers: {
        count: 1,
        criteria: 'senior-engineer'
      }
    },
    {
      name: 'architect-review',
      description: 'æ¶æ„å®¡æŸ¥',
      required: false,
      trigger: {
        architecturalChange: true,
        newDependencies: true,
        apiChanges: true
      },
      reviewers: {
        count: 1,
        criteria: 'architect'
      }
    }
  ]
};

// å®¡æŸ¥åˆ†é…ç®—æ³•
class ReviewAssigner {
  constructor(team) {
    this.team = team;
    this.workloadTracker = new Map();
  }

  assignReviewers(pullRequest) {
    const assignments = [];

    for (const level of reviewProcess.levels) {
      if (this.shouldTriggerLevel(level, pullRequest)) {
        const reviewers = this.selectReviewers(level, pullRequest);
        assignments.push({
          level: level.name,
          reviewers: reviewers
        });
      }
    }

    return assignments;
  }

  shouldTriggerLevel(level, pullRequest) {
    if (level.required) return true;

    const trigger = level.trigger;
    if (!trigger) return false;

    if (trigger.linesChanged &amp;&amp; pullRequest.linesChanged &gt; trigger.linesChanged) {
      return true;
    }

    if (trigger.filesChanged &amp;&amp; pullRequest.filesChanged &gt; trigger.filesChanged) {
      return true;
    }

    if (trigger.criticalPaths) {
      const hasCriticalChanges = pullRequest.files.some(file =&gt;
        trigger.criticalPaths.some(path =&gt; file.startsWith(path))
      );
      if (hasCriticalChanges) return true;
    }

    return false;
  }

  selectReviewers(level, pullRequest) {
    const candidates = this.getEligibleReviewers(level.reviewers.criteria, pullRequest.author);
    const count = level.reviewers.count;

    // æ ¹æ®å·¥ä½œè´Ÿè½½é€‰æ‹©å®¡æŸ¥è€…
    const sortedCandidates = candidates.sort((a, b) =&gt; {
      const workloadA = this.workloadTracker.get(a.id) || 0;
      const workloadB = this.workloadTracker.get(b.id) || 0;
      return workloadA - workloadB;
    });

    return sortedCandidates.slice(0, count);
  }

  getEligibleReviewers(criteria, author) {
    return this.team.filter(member =&gt; {
      if (member.id === author) return false;

      switch (criteria) {
        case 'same-team':
          return member.team === this.getAuthorTeam(author);
        case 'senior-engineer':
          return member.level &gt;= 4;
        case 'architect':
          return member.role === 'architect';
        default:
          return true;
      }
    });
  }
}
</code></pre>
<h3>å®¡æŸ¥åé¦ˆç³»ç»Ÿ</h3>
<p>æˆ‘ä»¬å»ºç«‹äº†ç»“æ„åŒ–çš„åé¦ˆç³»ç»Ÿï¼š</p>
<pre><code class="language-javascript">// å®¡æŸ¥åé¦ˆæ¨¡æ¿
class ReviewFeedback {
  constructor() {
    this.categories = {
      CRITICAL: {
        priority: 1,
        description: 'å¿…é¡»ä¿®å¤çš„é—®é¢˜',
        examples: ['å®‰å…¨æ¼æ´', 'åŠŸèƒ½é”™è¯¯', 'æ€§èƒ½é—®é¢˜']
      },
      MAJOR: {
        priority: 2,
        description: 'é‡è¦çš„æ”¹è¿›å»ºè®®',
        examples: ['ä»£ç ç»“æ„', 'æœ€ä½³å®è·µ', 'å¯ç»´æŠ¤æ€§']
      },
      MINOR: {
        priority: 3,
        description: 'å°çš„æ”¹è¿›å»ºè®®',
        examples: ['ä»£ç é£æ ¼', 'å‘½åä¼˜åŒ–', 'æ³¨é‡Šæ”¹è¿›']
      },
      SUGGESTION: {
        priority: 4,
        description: 'å¯é€‰çš„å»ºè®®',
        examples: ['æ›¿ä»£æ–¹æ¡ˆ', 'æ€§èƒ½ä¼˜åŒ–', 'åŠŸèƒ½å¢å¼º']
      }
    };
  }

  createFeedback(category, description, location, suggestion = null) {
    return {
      id: this.generateId(),
      category: category,
      priority: this.categories[category].priority,
      description: description,
      location: location,
      suggestion: suggestion,
      timestamp: new Date(),
      resolved: false
    };
  }

  // é¢„å®šä¹‰çš„åé¦ˆæ¨¡æ¿
  getCommonFeedbacks() {
    return {
      errorHandling: {
        category: 'MAJOR',
        template: 'å»ºè®®æ·»åŠ é”™è¯¯å¤„ç†ï¼š{suggestion}',
        suggestions: [
          'ä½¿ç”¨try-catchåŒ…è£…å¼‚æ­¥æ“ä½œ',
          'éªŒè¯è¾“å…¥å‚æ•°',
          'æä¾›æœ‰æ„ä¹‰çš„é”™è¯¯ä¿¡æ¯'
        ]
      },

      naming: {
        category: 'MINOR',
        template: 'å‘½åå¯ä»¥æ›´æ¸…æ™°ï¼š{suggestion}',
        suggestions: [
          'ä½¿ç”¨åŠ¨è¯+åè¯çš„å‡½æ•°å‘½å',
          'é¿å…ç¼©å†™å’Œæ¨¡ç³Šçš„åç§°',
          'ä¿æŒå‘½åçš„ä¸€è‡´æ€§'
        ]
      },

      performance: {
        category: 'MAJOR',
        template: 'æ€§èƒ½è€ƒè™‘ï¼š{suggestion}',
        suggestions: [
          'è€ƒè™‘ä½¿ç”¨æ›´é«˜æ•ˆçš„ç®—æ³•',
          'é¿å…ä¸å¿…è¦çš„å¾ªç¯',
          'å®ç°æ‡’åŠ è½½æˆ–ç¼“å­˜'
        ]
      },

      testing: {
        category: 'CRITICAL',
        template: 'æµ‹è¯•è¦†ç›–ä¸è¶³ï¼š{suggestion}',
        suggestions: [
          'æ·»åŠ å•å…ƒæµ‹è¯•',
          'æµ‹è¯•è¾¹ç•Œæ¡ä»¶',
          'æ·»åŠ é›†æˆæµ‹è¯•'
        ]
      }
    };
  }
}

// æ™ºèƒ½åé¦ˆåŠ©æ‰‹
class ReviewAssistant {
  constructor() {
    this.patterns = this.loadCommonPatterns();
  }

  loadCommonPatterns() {
    return [
      {
        pattern: /console\.log\(/g,
        category: 'MINOR',
        message: 'å‘ç°console.logï¼Œå»ºè®®ç§»é™¤æˆ–ä½¿ç”¨æ­£ç¡®çš„æ—¥å¿—åº“',
        autofix: true
      },
      {
        pattern: /\.catch\(\(\) =&gt; \{\}\)/g,
        category: 'CRITICAL',
        message: 'ç©ºçš„catchå—ä¼šéšè—é”™è¯¯ï¼Œå»ºè®®æ­£ç¡®å¤„ç†å¼‚å¸¸',
        autofix: false
      },
      {
        pattern: /== null|!= null/g,
        category: 'MINOR',
        message: 'å»ºè®®ä½¿ç”¨ä¸¥æ ¼æ¯”è¾ƒ(=== æˆ– !==)',
        autofix: true
      },
      {
        pattern: /var /g,
        category: 'MINOR',
        message: 'å»ºè®®ä½¿ç”¨constæˆ–letæ›¿ä»£var',
        autofix: true
      }
    ];
  }

  analyzeCode(code) {
    const suggestions = [];

    for (const pattern of this.patterns) {
      const matches = code.match(pattern.pattern);
      if (matches) {
        suggestions.push({
          category: pattern.category,
          message: pattern.message,
          occurrences: matches.length,
          autofix: pattern.autofix
        });
      }
    }

    return suggestions;
  }

  generateReviewSummary(pullRequest) {
    const summary = {
      overallRating: this.calculateOverallRating(pullRequest),
      keyIssues: this.identifyKeyIssues(pullRequest),
      strengths: this.identifyStrengths(pullRequest),
      recommendations: this.generateRecommendations(pullRequest)
    };

    return summary;
  }

  calculateOverallRating(pullRequest) {
    const criticalIssues = pullRequest.feedbacks.filter(f =&gt; f.category === 'CRITICAL').length;
    const majorIssues = pullRequest.feedbacks.filter(f =&gt; f.category === 'MAJOR').length;

    if (criticalIssues &gt; 0) return 'NEEDS_WORK';
    if (majorIssues &gt; 3) return 'NEEDS_IMPROVEMENT';
    if (majorIssues &gt; 0) return 'GOOD_WITH_SUGGESTIONS';
    return 'EXCELLENT';
  }
}
</code></pre>
<h2>æ–‡åŒ–å»ºè®¾å®è·µ</h2>
<h3>åŸ¹è®­å’ŒæŒ‡å¯¼</h3>
<p>æˆ‘ä»¬å®æ–½äº†ç³»ç»Ÿçš„åŸ¹è®­è®¡åˆ’ï¼š</p>
<pre><code class="language-javascript">// åŸ¹è®­è®¡åˆ’
const trainingProgram = {
  newJoiners: {
    duration: '2å‘¨',
    modules: [
      {
        name: 'ä»£ç å®¡æŸ¥åŸºç¡€',
        content: 'å®¡æŸ¥ç›®æ ‡ã€æµç¨‹ã€å·¥å…·ä½¿ç”¨',
        practicalExercise: 'å®¡æŸ¥æ¨¡æ‹ŸPR'
      },
      {
        name: 'å›¢é˜Ÿæ ‡å‡†',
        content: 'ç¼–ç è§„èŒƒã€æœ€ä½³å®è·µã€å¸¸è§é—®é¢˜',
        practicalExercise: 'æ ‡å‡†åŒ–æ”¹å†™ç»ƒä¹ '
      },
      {
        name: 'æœ‰æ•ˆåé¦ˆ',
        content: 'å¦‚ä½•ç»™å‡ºå»ºè®¾æ€§æ„è§ã€æ²Ÿé€šæŠ€å·§',
        practicalExercise: 'è§’è‰²æ‰®æ¼”ç»ƒä¹ '
      }
    ]
  },

  regularTraining: {
    frequency: 'æ¯æœˆ',
    formats: [
      'Tech Talk - åˆ†äº«å®¡æŸ¥å‘ç°çš„é—®é¢˜',
      'Case Study - åˆ†æå…¸å‹å®¡æŸ¥æ¡ˆä¾‹',
      'Workshop - ç»ƒä¹ å¤æ‚åœºæ™¯çš„å®¡æŸ¥',
      'Lightning Talk - åˆ†äº«å®¡æŸ¥æŠ€å·§'
    ]
  },

  advancedTopics: {
    frequency: 'æ¯å­£åº¦',
    topics: [
      'æ¶æ„å®¡æŸ¥æŠ€å·§',
      'æ€§èƒ½åˆ†ææ–¹æ³•',
      'å®‰å…¨å®¡æŸ¥è¦ç‚¹',
      'å¤§å‹é‡æ„çš„å®¡æŸ¥ç­–ç•¥'
    ]
  }
};

// æŒ‡å¯¼ç³»ç»Ÿ
class MentorshipSystem {
  constructor() {
    this.mentorPairs = new Map();
    this.progressTracking = new Map();
  }

  assignMentor(newbie, mentor) {
    this.mentorPairs.set(newbie.id, mentor.id);
    this.progressTracking.set(newbie.id, {
      startDate: new Date(),
      completedReviews: 0,
      receivedFeedback: [],
      skillProgress: this.initializeSkillTracker()
    });
  }

  initializeSkillTracker() {
    return {
      codeQuality: 0,
      communicationSkills: 0,
      technicalDepth: 0,
      processAdherence: 0
    };
  }

  recordReviewProgress(menteeId, reviewData) {
    const progress = this.progressTracking.get(menteeId);
    if (!progress) return;

    progress.completedReviews++;
    progress.receivedFeedback.push(reviewData);

    // æ›´æ–°æŠ€èƒ½è¯„åˆ†
    this.updateSkillScores(progress, reviewData);
  }

  updateSkillScores(progress, reviewData) {
    // åŸºäºå®¡æŸ¥è´¨é‡æ›´æ–°æŠ€èƒ½åˆ†æ•°
    const qualityScore = this.calculateReviewQuality(reviewData);

    progress.skillProgress.codeQuality = 
      (progress.skillProgress.codeQuality + qualityScore) / 2;
  }

  generateProgressReport(menteeId) {
    const progress = this.progressTracking.get(menteeId);
    const mentorId = this.mentorPairs.get(menteeId);

    return {
      mentee: menteeId,
      mentor: mentorId,
      duration: this.calculateDuration(progress.startDate),
      completedReviews: progress.completedReviews,
      skillProgress: progress.skillProgress,
      nextSteps: this.generateNextSteps(progress)
    };
  }
}
</code></pre>
<h3>æ¿€åŠ±æœºåˆ¶</h3>
<p>æˆ‘ä»¬å»ºç«‹äº†å¤šæ ·åŒ–çš„æ¿€åŠ±æœºåˆ¶ï¼š</p>
<pre><code class="language-javascript">// æ¿€åŠ±ç³»ç»Ÿ
class ReviewIncentiveSystem {
  constructor() {
    this.points = new Map();
    this.achievements = new Map();
    this.leaderboards = new Map();
  }

  awardPoints(userId, action, quality = 'good') {
    const pointsConfig = {
      review_completed: { good: 10, excellent: 15, outstanding: 20 },
      feedback_helpful: { good: 5, excellent: 10, outstanding: 15 },
      bug_found: { good: 20, excellent: 30, outstanding: 50 },
      improvement_suggested: { good: 8, excellent: 12, outstanding: 18 }
    };

    const points = pointsConfig[action]?.[quality] || 0;
    const currentPoints = this.points.get(userId) || 0;
    this.points.set(userId, currentPoints + points);

    this.checkAchievements(userId);
  }

  checkAchievements(userId) {
    const userPoints = this.points.get(userId) || 0;
    const userAchievements = this.achievements.get(userId) || new Set();

    const achievementRules = [
      { id: 'first_review', condition: () =&gt; userPoints &gt;= 10, title: 'é¦–æ¬¡å®¡æŸ¥' },
      { id: 'helpful_reviewer', condition: () =&gt; userPoints &gt;= 100, title: 'æœ‰ç”¨çš„å®¡æŸ¥è€…' },
      { id: 'bug_hunter', condition: () =&gt; this.getBugCount(userId) &gt;= 5, title: 'BugçŒäºº' },
      { id: 'quality_guardian', condition: () =&gt; userPoints &gt;= 500, title: 'è´¨é‡å®ˆæŠ¤è€…' },
      { id: 'master_reviewer', condition: () =&gt; userPoints &gt;= 1000, title: 'å®¡æŸ¥å¤§å¸ˆ' }
    ];

    for (const rule of achievementRules) {
      if (!userAchievements.has(rule.id) &amp;&amp; rule.condition()) {
        userAchievements.add(rule.id);
        this.announceAchievement(userId, rule);
      }
    }

    this.achievements.set(userId, userAchievements);
  }

  announceAchievement(userId, achievement) {
    // å‘é€é€šçŸ¥ã€åœ¨å›¢é˜Ÿé¢‘é“å®£å¸ƒç­‰
    console.log(`ğŸ‰ ${userId} è·å¾—æˆå°±: ${achievement.title}`);
  }

  generateMonthlyReport() {
    return {
      topReviewers: this.getTopReviewers(),
      mostHelpfulFeedback: this.getMostHelpfulFeedback(),
      qualityTrends: this.getQualityTrends(),
      teamStats: this.getTeamStats()
    };
  }

  getTopReviewers() {
    return Array.from(this.points.entries())
      .sort((a, b) =&gt; b[1] - a[1])
      .slice(0, 5)
      .map(([userId, points], index) =&gt; ({
        rank: index + 1,
        userId,
        points
      }));
  }
}
</code></pre>
<h2>æŠ€æœ¯å·¥å…·æ”¯æŒ</h2>
<h3>è‡ªåŠ¨åŒ–å®¡æŸ¥å·¥å…·</h3>
<p>æˆ‘ä»¬å¼€å‘äº†è‡ªåŠ¨åŒ–å·¥å…·æ¥è¾…åŠ©å®¡æŸ¥ï¼š</p>
<pre><code class="language-javascript">// è‡ªåŠ¨åŒ–å®¡æŸ¥å·¥å…·
class AutomatedReviewTools {
  constructor() {
    this.linters = new Map();
    this.securityScanners = new Map();
    this.qualityGates = new Map();

    this.setupTools();
  }

  setupTools() {
    // ä»£ç è´¨é‡æ£€æŸ¥
    this.linters.set('javascript', {
      tool: 'eslint',
      config: '.eslintrc.js',
      rules: 'custom-rules'
    });

    this.linters.set('typescript', {
      tool: 'tslint',
      config: 'tslint.json',
      rules: 'strict'
    });

    // å®‰å…¨æ‰«æ
    this.securityScanners.set('dependencies', {
      tool: 'npm audit',
      severity: 'moderate'
    });

    this.securityScanners.set('static', {
      tool: 'semgrep',
      ruleset: 'security'
    });

    // è´¨é‡é—¨ç¦
    this.qualityGates.set('coverage', {
      threshold: 80,
      tool: 'jest'
    });

    this.qualityGates.set('complexity', {
      threshold: 10,
      tool: 'complexity-report'
    });
  }

  async runAutomatedChecks(pullRequest) {
    const results = {
      linting: await this.runLinting(pullRequest),
      security: await this.runSecurityScan(pullRequest),
      quality: await this.runQualityChecks(pullRequest),
      tests: await this.runTests(pullRequest)
    };

    return this.generateReport(results);
  }

  async runLinting(pullRequest) {
    const results = [];

    for (const file of pullRequest.files) {
      const extension = file.split('.').pop();
      const linter = this.linters.get(extension);

      if (linter) {
        const result = await this.executeLinter(linter, file);
        results.push({
          file,
          issues: result.issues,
          fixable: result.fixable
        });
      }
    }

    return results;
  }

  async runSecurityScan(pullRequest) {
    const scanResults = [];

    for (const [scanType, config] of this.securityScanners) {
      const result = await this.executeSecurityScan(config, pullRequest);
      scanResults.push({
        type: scanType,
        vulnerabilities: result.vulnerabilities,
        severity: result.severity
      });
    }

    return scanResults;
  }

  generateReport(results) {
    const report = {
      overall: 'pass', // pass, warning, fail
      details: results,
      summary: {
        lintingIssues: this.countLintingIssues(results.linting),
        securityVulns: this.countSecurityIssues(results.security),
        qualityGatesPassed: this.checkQualityGates(results.quality),
        testsPassed: results.tests.passed
      },
      actionItems: this.generateActionItems(results)
    };

    // ç¡®å®šæ•´ä½“çŠ¶æ€
    if (report.summary.securityVulns.high &gt; 0 || !report.summary.testsPassed) {
      report.overall = 'fail';
    } else if (report.summary.lintingIssues &gt; 10 || report.summary.securityVulns.medium &gt; 0) {
      report.overall = 'warning';
    }

    return report;
  }
}
</code></pre>
<h3>å®¡æŸ¥æ•°æ®åˆ†æ</h3>
<p>æˆ‘ä»¬å»ºç«‹äº†æ•°æ®åˆ†æç³»ç»Ÿæ¥æŒç»­æ”¹è¿›ï¼š</p>
<pre><code class="language-javascript">// å®¡æŸ¥æ•°æ®åˆ†æ
class ReviewAnalytics {
  constructor() {
    this.database = new ReviewDatabase();
    this.metrics = new Map();
  }

  async analyzeReviewTrends() {
    const data = await this.database.getReviewData();

    return {
      throughputTrends: this.analyzeThroughput(data),
      qualityTrends: this.analyzeQuality(data),
      participationTrends: this.analyzeParticipation(data),
      issuePatterns: this.analyzeIssuePatterns(data),
      timeMetrics: this.analyzeTimeMetrics(data)
    };
  }

  analyzeThroughput(data) {
    const monthlyData = this.groupByMonth(data);

    return monthlyData.map(month =&gt; ({
      period: month.period,
      totalReviews: month.reviews.length,
      averageTimeToApprove: this.calculateAverageTime(month.reviews, 'approval'),
      averageTimeToMerge: this.calculateAverageTime(month.reviews, 'merge'),
      rejectionRate: this.calculateRejectionRate(month.reviews)
    }));
  }

  analyzeQuality(data) {
    return {
      defectEscapeRate: this.calculateDefectEscapeRate(data),
      reworkRate: this.calculateReworkRate(data),
      reviewEffectiveness: this.calculateReviewEffectiveness(data),
      codeQualityTrends: this.analyzeCodeQuality(data)
    };
  }

  analyzeParticipation(data) {
    const reviewerStats = new Map();

    data.forEach(review =&gt; {
      review.reviewers.forEach(reviewer =&gt; {
        if (!reviewerStats.has(reviewer.id)) {
          reviewerStats.set(reviewer.id, {
            totalReviews: 0,
            averageQuality: 0,
            timeSpent: 0,
            issuesFound: 0
          });
        }

        const stats = reviewerStats.get(reviewer.id);
        stats.totalReviews++;
        stats.timeSpent += reviewer.timeSpent;
        stats.issuesFound += reviewer.issuesFound;
      });
    });

    return Array.from(reviewerStats.entries()).map(([reviewerId, stats]) =&gt; ({
      reviewerId,
      ...stats,
      averageTimePerReview: stats.timeSpent / stats.totalReviews,
      averageIssuesPerReview: stats.issuesFound / stats.totalReviews
    }));
  }

  generateInsights(analytics) {
    const insights = [];

    // ååé‡æ´å¯Ÿ
    const latestThroughput = analytics.throughputTrends.slice(-1)[0];
    if (latestThroughput.averageTimeToApprove &gt; 48) { // 48å°æ—¶
      insights.push({
        type: 'warning',
        category: 'throughput',
        message: 'å®¡æŸ¥æ‰¹å‡†æ—¶é—´è¿‡é•¿ï¼Œå¯èƒ½éœ€è¦å¢åŠ å®¡æŸ¥è€…æˆ–ä¼˜åŒ–æµç¨‹',
        data: latestThroughput
      });
    }

    // è´¨é‡æ´å¯Ÿ
    if (analytics.qualityTrends.defectEscapeRate &gt; 0.1) { // 10%
      insights.push({
        type: 'critical',
        category: 'quality',
        message: 'ç¼ºé™·é€ƒé€¸ç‡è¿‡é«˜ï¼Œéœ€è¦åŠ å¼ºå®¡æŸ¥æ·±åº¦',
        recommendation: 'è€ƒè™‘å¢åŠ ä¸“é¡¹å®‰å…¨å®¡æŸ¥å’Œæ€§èƒ½å®¡æŸ¥'
      });
    }

    // å‚ä¸åº¦æ´å¯Ÿ
    const lowParticipation = analytics.participationTrends.filter(p =&gt; p.totalReviews &lt; 5);
    if (lowParticipation.length &gt; 0) {
      insights.push({
        type: 'info',
        category: 'participation',
        message: `${lowParticipation.length}ä½æˆå‘˜å‚ä¸åº¦è¾ƒä½`,
        recommendation: 'è€ƒè™‘æä¾›é¢å¤–åŸ¹è®­æˆ–è°ƒæ•´å®¡æŸ¥åˆ†é…ç­–ç•¥'
      });
    }

    return insights;
  }
}
</code></pre>
<h2>æˆæœä¸å½±å“</h2>
<p>ç»è¿‡ä¸€å¹´çš„åŠªåŠ›ï¼Œæˆ‘ä»¬çš„ä»£ç å®¡æŸ¥æ–‡åŒ–å»ºè®¾å–å¾—äº†æ˜¾è‘—æˆæœï¼š</p>
<h3>é‡åŒ–æŒ‡æ ‡</h3>
<pre><code class="language-javascript">const improvements = {
  codeQuality: {
    defectRate: { before: 15, after: 3, improvement: '80%' },
    reworkRate: { before: 25, after: 8, improvement: '68%' },
    techDebtReduction: '45%'
  },

  teamEfficiency: {
    reviewThroughput: { before: 2.5, after: 1.2, unit: 'days' },
    participationRate: { before: 45, after: 85, unit: '%' },
    knowledgeSharing: 'æ˜¾è‘—æå‡'
  },

  teamCulture: {
    satisfactionScore: { before: 6.2, after: 8.4, scale: '1-10' },
    collaborationImprovement: 'æ˜æ˜¾',
    learningCulture: 'ç§¯æå‘ä¸Š'
  }
};
</code></pre>
<h3>å›¢é˜Ÿåé¦ˆ</h3>
<p>æœ€é‡è¦çš„æ˜¯å›¢é˜Ÿæˆå‘˜çš„ç§¯æåé¦ˆï¼š</p>
<ul>
<li>"ç°åœ¨åšä»£ç å®¡æŸ¥ä¸å†æ˜¯è´Ÿæ‹…ï¼Œè€Œæ˜¯å­¦ä¹ çš„æœºä¼š"</li>
<li>"å®¡æŸ¥æµç¨‹å¸®åŠ©æˆ‘å‘ç°äº†å¾ˆå¤šç›²ç‚¹"</li>
<li>"å›¢é˜Ÿçš„æŠ€æœ¯æ°´å¹³æ•´ä½“æå‡äº†"</li>
<li>"ä»£ç è´¨é‡æ˜æ˜¾æ”¹å–„ï¼Œç»´æŠ¤æˆæœ¬é™ä½äº†"</li>
</ul>
<p>The implementation leveraged spatiotemporal modeling techniques to understand code change patterns over time, developed lightweight engines for automated code analysis, and created multi-modal data integration systems that combined human feedback with automated tool results.</p>
<h2>æŒç»­æ”¹è¿›è®¡åˆ’</h2>
<p>ä»£ç å®¡æŸ¥æ–‡åŒ–å»ºè®¾æ˜¯ä¸€ä¸ªæŒç»­çš„è¿‡ç¨‹ï¼š</p>
<pre><code class="language-javascript">const futureImprovements = {
  shortTerm: [
    'å¼•å…¥AIè¾…åŠ©å®¡æŸ¥å·¥å…·',
    'å»ºç«‹è·¨å›¢é˜Ÿå®¡æŸ¥æœºåˆ¶',
    'ä¼˜åŒ–ç§»åŠ¨ç«¯å®¡æŸ¥ä½“éªŒ'
  ],

  mediumTerm: [
    'å®æ–½é¢„æµ‹æ€§è´¨é‡åˆ†æ',
    'å»ºç«‹ä»£ç è´¨é‡é¢„è­¦ç³»ç»Ÿ',
    'å¼€å‘è‡ªé€‚åº”å®¡æŸ¥æµç¨‹'
  ],

  longTerm: [
    'æ„å»ºæ™ºèƒ½å®¡æŸ¥åŠ©æ‰‹',
    'å®ç°å…¨è‡ªåŠ¨è´¨é‡ç›‘æ§',
    'å»ºç«‹è¡Œä¸šæœ€ä½³å®è·µæ ‡æ†'
  ]
};
</code></pre>
<h2>æ€»ç»“</h2>
<p>å»ºè®¾è‰¯å¥½çš„ä»£ç å®¡æŸ¥æ–‡åŒ–éœ€è¦ï¼š</p>
<ol>
<li><strong>æ˜ç¡®çš„æ ‡å‡†å’Œæµç¨‹</strong>ï¼šè®©æ¯ä¸ªäººéƒ½çŸ¥é“è¯¥åšä»€ä¹ˆ</li>
<li><strong>æœ‰æ•ˆçš„å·¥å…·æ”¯æŒ</strong>ï¼šè‡ªåŠ¨åŒ–èƒ½åšçš„äº‹æƒ…ï¼Œè§£æ”¾äººçš„ç²¾åŠ›</li>
<li><strong>æŒç»­çš„åŸ¹è®­å’ŒæŒ‡å¯¼</strong>ï¼šå¸®åŠ©å›¢é˜Ÿæˆå‘˜æå‡æŠ€èƒ½</li>
<li><strong>æ­£å‘çš„æ¿€åŠ±æœºåˆ¶</strong>ï¼šè®©åšå¥½å®¡æŸ¥æˆä¸ºä¸€ç§è£èª‰</li>
<li><strong>æ•°æ®é©±åŠ¨çš„æ”¹è¿›</strong>ï¼šç”¨æ•°æ®æŒ‡å¯¼æŒç»­ä¼˜åŒ–</li>
</ol>
<p>æœ€é‡è¦çš„æ˜¯è¦è®°ä½ï¼Œä»£ç å®¡æŸ¥ä¸ä»…ä»…æ˜¯å‘ç°bugï¼Œæ›´æ˜¯å›¢é˜Ÿå­¦ä¹ ã€çŸ¥è¯†ä¼ æ‰¿å’Œæ–‡åŒ–å»ºè®¾çš„é‡è¦é€”å¾„ã€‚åªæœ‰å½“å›¢é˜Ÿæˆå‘˜éƒ½è®¤è¯†åˆ°è¿™ä¸€ç‚¹ï¼Œä»£ç å®¡æŸ¥æ–‡åŒ–æ‰èƒ½çœŸæ­£è½åœ°ç”Ÿæ ¹ã€‚</p>
                </div>
            </article>
        </div>
    </main>
    
    <footer>
        <p>&copy; 2025 æˆ‘çš„åšå®¢. All rights reserved.</p>
    </footer>
</body>
</html>