<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>数据库设计模式与性能优化实战：从关系型到NoSQL的演进之路 - 我的博客</title>
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <header>
        <h1 class="slogan">记录思考，分享生活</h1>
    </header>
    
    <main>
        <div class="container">
            <a href="../index.html" class="back-link">← 返回首页</a>
            
            <article class="article-page">
                <div class="article-header">
                    <h1>数据库设计模式与性能优化实战：从关系型到NoSQL的演进之路</h1>
                    <p class="article-date">2025年07月03日</p>
                </div>
                
                <div class="article-content">
                    <p><strong>Date: June 21, 2024</strong></p>
<p>最近公司的几个项目都遇到了数据库性能瓶颈问题，从传统的关系型数据库到现代的NoSQL解决方案，我在这个过程中积累了不少实战经验。今天想系统性地总结一下数据库设计模式和性能优化的最佳实践。</p>
<h2>关系型数据库设计模式</h2>
<h3>基础设计原则</h3>
<p>在开始任何数据库设计之前，我们需要明确几个核心原则：</p>
<pre><code class="language-sql">-- 数据库设计的SOLID原则应用
-- 1. 单一职责原则：每个表只负责一个业务实体
CREATE TABLE users (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) NOT NULL UNIQUE,
    email VARCHAR(100) NOT NULL UNIQUE,
    password_hash VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_username (username),
    INDEX idx_email (email)
);

-- 2. 开放封闭原则：设计易于扩展的表结构
CREATE TABLE user_profiles (
    user_id BIGINT PRIMARY KEY,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    bio TEXT,
    avatar_url VARCHAR(255),
    birth_date DATE,
    timezone VARCHAR(50),
    locale VARCHAR(10),
    -- 扩展字段，使用JSON存储额外属性
    metadata JSON,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

-- 3. 里氏替换原则：子类型必须能够替换它们的基类型
CREATE TABLE content_items (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    type ENUM('article', 'video', 'podcast', 'image') NOT NULL,
    title VARCHAR(255) NOT NULL,
    description TEXT,
    author_id BIGINT NOT NULL,
    status ENUM('draft', 'published', 'archived') DEFAULT 'draft',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_type_status (type, status),
    INDEX idx_author_created (author_id, created_at),
    FOREIGN KEY (author_id) REFERENCES users(id)
);

-- 多态设计：不同类型的内容有不同的属性
CREATE TABLE articles (
    content_id BIGINT PRIMARY KEY,
    content TEXT NOT NULL,
    word_count INT,
    reading_time INT, -- 预计阅读时间（分钟）
    FOREIGN KEY (content_id) REFERENCES content_items(id) ON DELETE CASCADE
);

CREATE TABLE videos (
    content_id BIGINT PRIMARY KEY,
    video_url VARCHAR(255) NOT NULL,
    duration INT, -- 时长（秒）
    resolution VARCHAR(20),
    file_size BIGINT,
    FOREIGN KEY (content_id) REFERENCES content_items(id) ON DELETE CASCADE
);
</code></pre>
<h3>高级索引策略</h3>
<pre><code class="language-sql">-- 复合索引设计最佳实践
CREATE TABLE orders (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    product_id BIGINT NOT NULL,
    quantity INT NOT NULL,
    unit_price DECIMAL(10,2) NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL,
    order_status ENUM('pending', 'paid', 'shipped', 'delivered', 'cancelled') NOT NULL,
    order_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    shipping_date TIMESTAMP NULL,
    delivery_date TIMESTAMP NULL,

    -- 主要查询场景的索引设计
    INDEX idx_user_status_date (user_id, order_status, order_date), -- 用户订单查询
    INDEX idx_product_status (product_id, order_status), -- 产品销售统计
    INDEX idx_status_date (order_status, order_date), -- 订单状态报表
    INDEX idx_date_amount (order_date, total_amount), -- 销售额统计

    -- 覆盖索引：避免回表查询
    INDEX idx_user_summary (user_id, order_status, total_amount, order_date),

    FOREIGN KEY (user_id) REFERENCES users(id),
    FOREIGN KEY (product_id) REFERENCES products(id)
);

-- 函数索引（MySQL 8.0+）
ALTER TABLE orders ADD INDEX idx_year_month ((YEAR(order_date)), (MONTH(order_date)));

-- 部分索引：只为符合条件的行创建索引
CREATE INDEX idx_active_orders ON orders (user_id, order_date) 
WHERE order_status IN ('pending', 'paid', 'shipped');
</code></pre>
<h3>分区表设计</h3>
<pre><code class="language-sql">-- 按时间分区的订单表
CREATE TABLE orders_partitioned (
    id BIGINT NOT NULL,
    user_id BIGINT NOT NULL,
    product_id BIGINT NOT NULL,
    quantity INT NOT NULL,
    unit_price DECIMAL(10,2) NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL,
    order_status ENUM('pending', 'paid', 'shipped', 'delivered', 'cancelled') NOT NULL,
    order_date TIMESTAMP NOT NULL,

    PRIMARY KEY (id, order_date),
    INDEX idx_user_status (user_id, order_status),
    INDEX idx_product (product_id)
) 
PARTITION BY RANGE (YEAR(order_date)) (
    PARTITION p2022 VALUES LESS THAN (2023),
    PARTITION p2023 VALUES LESS THAN (2024),
    PARTITION p2024 VALUES LESS THAN (2025),
    PARTITION p2025 VALUES LESS THAN (2026),
    PARTITION p_future VALUES LESS THAN MAXVALUE
);

-- 分区维护脚本
DELIMITER //
CREATE PROCEDURE maintain_order_partitions()
BEGIN
    DECLARE next_year INT;
    SET next_year = YEAR(CURDATE()) + 1;

    -- 添加明年的分区
    SET @sql = CONCAT('ALTER TABLE orders_partitioned ADD PARTITION (PARTITION p', 
                     next_year, ' VALUES LESS THAN (', next_year + 1, '))');
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;

    -- 删除3年前的分区（保留历史数据的同时控制表大小）
    SET @old_year = next_year - 3;
    SET @sql = CONCAT('ALTER TABLE orders_partitioned DROP PARTITION p', @old_year);
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
END //
DELIMITER ;

-- 设置定时任务
CREATE EVENT ev_maintain_partitions
ON SCHEDULE EVERY 1 YEAR
STARTS '2024-01-01 00:00:00'
DO CALL maintain_order_partitions();
</code></pre>
<h2>查询优化技巧</h2>
<h3>SQL性能优化实战</h3>
<pre><code class="language-sql">-- 案例1：N+1查询问题的解决
-- 错误的做法：导致N+1查询
SELECT * FROM users WHERE status = 'active';
-- 然后在应用层循环查询每个用户的订单
-- SELECT * FROM orders WHERE user_id = ?;

-- 正确的做法：使用JOIN或子查询
SELECT 
    u.id,
    u.username,
    u.email,
    o.order_count,
    o.total_amount
FROM users u
LEFT JOIN (
    SELECT 
        user_id,
        COUNT(*) as order_count,
        SUM(total_amount) as total_amount
    FROM orders 
    WHERE order_status != 'cancelled'
    GROUP BY user_id
) o ON u.id = o.user_id
WHERE u.status = 'active';

-- 案例2：分页查询优化
-- 错误的做法：大偏移量的LIMIT查询
SELECT * FROM orders ORDER BY order_date DESC LIMIT 1000000, 20;

-- 正确的做法：基于游标的分页
SELECT * FROM orders 
WHERE order_date &lt; '2024-06-01 12:00:00'  -- 使用上一页的最后一个时间戳
ORDER BY order_date DESC 
LIMIT 20;

-- 案例3：复杂查询的重构
-- 原始查询：性能较差
SELECT 
    u.username,
    COUNT(DISTINCT o.id) as order_count,
    COUNT(DISTINCT p.id) as product_count,
    AVG(o.total_amount) as avg_order_amount
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
LEFT JOIN order_items oi ON o.id = oi.order_id
LEFT JOIN products p ON oi.product_id = p.id
WHERE u.created_at &gt;= '2024-01-01'
GROUP BY u.id, u.username;

-- 优化后的查询：分步骤计算
WITH user_orders AS (
    SELECT 
        u.id,
        u.username,
        COUNT(o.id) as order_count,
        AVG(o.total_amount) as avg_order_amount
    FROM users u
    LEFT JOIN orders o ON u.id = o.user_id
    WHERE u.created_at &gt;= '2024-01-01'
    GROUP BY u.id, u.username
),
user_products AS (
    SELECT 
        u.id,
        COUNT(DISTINCT oi.product_id) as product_count
    FROM users u
    LEFT JOIN orders o ON u.id = o.user_id
    LEFT JOIN order_items oi ON o.id = oi.order_id
    WHERE u.created_at &gt;= '2024-01-01'
    GROUP BY u.id
)
SELECT 
    uo.username,
    uo.order_count,
    COALESCE(up.product_count, 0) as product_count,
    uo.avg_order_amount
FROM user_orders uo
LEFT JOIN user_products up ON uo.id = up.id;
</code></pre>
<h3>查询执行计划分析</h3>
<pre><code class="language-sql">-- 使用EXPLAIN分析查询性能
EXPLAIN FORMAT=JSON
SELECT 
    u.username,
    COUNT(o.id) as order_count,
    SUM(o.total_amount) as total_spent
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
WHERE u.created_at &gt;= '2024-01-01'
    AND o.order_status = 'delivered'
GROUP BY u.id, u.username
ORDER BY total_spent DESC
LIMIT 100;

-- 性能监控查询
SELECT 
    SCHEMA_NAME,
    DIGEST_TEXT,
    COUNT_STAR,
    AVG_TIMER_WAIT/1000000000 as avg_time_sec,
    SUM_TIMER_WAIT/1000000000 as total_time_sec,
    AVG_ROWS_EXAMINED,
    AVG_ROWS_SENT
FROM performance_schema.events_statements_summary_by_digest 
WHERE SCHEMA_NAME = 'your_database_name'
ORDER BY AVG_TIMER_WAIT DESC
LIMIT 20;

-- 慢查询日志分析
SELECT 
    sql_text,
    exec_count,
    avg_query_time,
    avg_lock_time,
    avg_rows_sent,
    avg_rows_examined
FROM mysql.slow_log 
WHERE start_time &gt;= DATE_SUB(NOW(), INTERVAL 1 DAY)
ORDER BY avg_query_time DESC;
</code></pre>
<h2>NoSQL数据库设计模式</h2>
<h3>MongoDB文档设计</h3>
<pre><code class="language-javascript">// MongoDB文档设计最佳实践
// 1. 嵌入式文档 vs 引用文档的选择

// 适合嵌入的场景：一对少的关系，子文档不会独立查询
const userWithProfile = {
    _id: ObjectId(&quot;...&quot;),
    username: &quot;johndoe&quot;,
    email: &quot;john@example.com&quot;,
    profile: {
        firstName: &quot;John&quot;,
        lastName: &quot;Doe&quot;,
        bio: &quot;Software developer&quot;,
        socialLinks: {
            twitter: &quot;@johndoe&quot;,
            github: &quot;johndoe&quot;,
            linkedin: &quot;johndoe&quot;
        },
        preferences: {
            theme: &quot;dark&quot;,
            language: &quot;en&quot;,
            notifications: {
                email: true,
                push: false,
                sms: false
            }
        }
    },
    createdAt: new Date(),
    updatedAt: new Date()
};

// 适合引用的场景：一对多或多对多关系，子文档会独立查询
const blogPost = {
    _id: ObjectId(&quot;...&quot;),
    title: &quot;Database Design Patterns&quot;,
    content: &quot;...&quot;,
    authorId: ObjectId(&quot;...&quot;), // 引用用户
    tags: [&quot;database&quot;, &quot;mongodb&quot;, &quot;design&quot;], // 嵌入简单数组
    comments: [], // 评论单独存储，这里只存引用
    metadata: {
        views: 1250,
        likes: 45,
        shares: 12,
        readingTime: 8
    },
    publishedAt: new Date(),
    updatedAt: new Date()
};

const comment = {
    _id: ObjectId(&quot;...&quot;),
    postId: ObjectId(&quot;...&quot;), // 引用博客文章
    authorId: ObjectId(&quot;...&quot;), // 引用用户
    content: &quot;Great article!&quot;,
    replies: [ // 嵌入回复（有限深度）
        {
            _id: ObjectId(&quot;...&quot;),
            authorId: ObjectId(&quot;...&quot;),
            content: &quot;I agree!&quot;,
            createdAt: new Date()
        }
    ],
    createdAt: new Date(),
    updatedAt: new Date()
};

// 2. 数据去范式化设计
const orderDocument = {
    _id: ObjectId(&quot;...&quot;),
    orderNumber: &quot;ORD-2024-001234&quot;,

    // 嵌入常用的用户信息（快照）
    customer: {
        id: ObjectId(&quot;...&quot;),
        name: &quot;John Doe&quot;,
        email: &quot;john@example.com&quot;,
        shippingAddress: {
            street: &quot;123 Main St&quot;,
            city: &quot;New York&quot;,
            state: &quot;NY&quot;,
            zipCode: &quot;10001&quot;,
            country: &quot;USA&quot;
        }
    },

    // 嵌入订单项信息
    items: [
        {
            productId: ObjectId(&quot;...&quot;),
            productName: &quot;MacBook Pro 16\&quot;&quot;, // 冗余存储，提高查询性能
            productSku: &quot;MBP16-2024&quot;,
            price: 2499.00,
            quantity: 1,
            subtotal: 2499.00
        }
    ],

    // 订单汇总信息
    summary: {
        itemsCount: 1,
        subtotal: 2499.00,
        tax: 199.92,
        shipping: 0.00,
        total: 2698.92
    },

    // 订单状态历史
    statusHistory: [
        {
            status: &quot;pending&quot;,
            timestamp: new Date(&quot;2024-06-01T10:00:00Z&quot;),
            note: &quot;Order created&quot;
        },
        {
            status: &quot;paid&quot;,
            timestamp: new Date(&quot;2024-06-01T10:05:00Z&quot;),
            note: &quot;Payment processed&quot;
        },
        {
            status: &quot;shipped&quot;,
            timestamp: new Date(&quot;2024-06-02T14:30:00Z&quot;),
            note: &quot;Package shipped via UPS&quot;,
            trackingNumber: &quot;1Z999AA1234567890&quot;
        }
    ],

    createdAt: new Date(),
    updatedAt: new Date()
};
</code></pre>
<h3>MongoDB聚合查询优化</h3>
<pre><code class="language-javascript">// 高性能聚合管道设计
// 1. 电商订单分析示例
const orderAnalytics = [
    // 第一阶段：筛选最近30天的已完成订单
    {
        $match: {
            &quot;statusHistory.status&quot;: &quot;delivered&quot;,
            createdAt: {
                $gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000)
            }
        }
    },

    // 第二阶段：解构订单项
    {
        $unwind: &quot;$items&quot;
    },

    // 第三阶段：按产品分组统计
    {
        $group: {
            _id: &quot;$items.productId&quot;,
            productName: { $first: &quot;$items.productName&quot; },
            totalQuantity: { $sum: &quot;$items.quantity&quot; },
            totalRevenue: { $sum: &quot;$items.subtotal&quot; },
            orderCount: { $sum: 1 },
            avgOrderValue: { $avg: &quot;$items.subtotal&quot; }
        }
    },

    // 第四阶段：计算附加指标
    {
        $addFields: {
            revenuePerUnit: {
                $divide: [&quot;$totalRevenue&quot;, &quot;$totalQuantity&quot;]
            }
        }
    },

    // 第五阶段：排序和限制结果
    {
        $sort: { totalRevenue: -1 }
    },
    {
        $limit: 50
    },

    // 第六阶段：关联产品详细信息
    {
        $lookup: {
            from: &quot;products&quot;,
            localField: &quot;_id&quot;,
            foreignField: &quot;_id&quot;,
            as: &quot;productDetails&quot;
        }
    },

    // 第七阶段：整理输出格式
    {
        $project: {
            _id: 1,
            productName: 1,
            category: { $arrayElemAt: [&quot;$productDetails.category&quot;, 0] },
            totalQuantity: 1,
            totalRevenue: { $round: [&quot;$totalRevenue&quot;, 2] },
            orderCount: 1,
            avgOrderValue: { $round: [&quot;$avgOrderValue&quot;, 2] },
            revenuePerUnit: { $round: [&quot;$revenuePerUnit&quot;, 2] }
        }
    }
];

// 执行聚合查询
db.orders.aggregate(orderAnalytics);

// 2. 用户行为分析聚合
const userBehaviorAnalysis = [
    {
        $match: {
            createdAt: {
                $gte: new Date(&quot;2024-01-01&quot;),
                $lte: new Date(&quot;2024-06-30&quot;)
            }
        }
    },
    {
        $group: {
            _id: {
                userId: &quot;$customer.id&quot;,
                month: { $month: &quot;$createdAt&quot; },
                year: { $year: &quot;$createdAt&quot; }
            },
            monthlyOrders: { $sum: 1 },
            monthlySpending: { $sum: &quot;$summary.total&quot; },
            avgOrderValue: { $avg: &quot;$summary.total&quot; },
            uniqueProducts: { $addToSet: &quot;$items.productId&quot; }
        }
    },
    {
        $addFields: {
            uniqueProductCount: { $size: &quot;$uniqueProducts&quot; }
        }
    },
    {
        $group: {
            _id: &quot;$_id.userId&quot;,
            months: {
                $push: {
                    month: &quot;$_id.month&quot;,
                    year: &quot;$_id.year&quot;,
                    orders: &quot;$monthlyOrders&quot;,
                    spending: &quot;$monthlySpending&quot;,
                    avgOrderValue: &quot;$avgOrderValue&quot;,
                    uniqueProducts: &quot;$uniqueProductCount&quot;
                }
            },
            totalOrders: { $sum: &quot;$monthlyOrders&quot; },
            totalSpending: { $sum: &quot;$monthlySpending&quot; },
            overallAvgOrderValue: { $avg: &quot;$avgOrderValue&quot; }
        }
    },
    {
        $lookup: {
            from: &quot;users&quot;,
            localField: &quot;_id&quot;,
            foreignField: &quot;_id&quot;,
            as: &quot;userInfo&quot;
        }
    },
    {
        $project: {
            username: { $arrayElemAt: [&quot;$userInfo.username&quot;, 0] },
            email: { $arrayElemAt: [&quot;$userInfo.email&quot;, 0] },
            totalOrders: 1,
            totalSpending: { $round: [&quot;$totalSpending&quot;, 2] },
            overallAvgOrderValue: { $round: [&quot;$overallAvgOrderValue&quot;, 2] },
            months: 1,
            customerSegment: {
                $switch: {
                    branches: [
                        {
                            case: { $gte: [&quot;$totalSpending&quot;, 10000] },
                            then: &quot;VIP&quot;
                        },
                        {
                            case: { $gte: [&quot;$totalSpending&quot;, 5000] },
                            then: &quot;Premium&quot;
                        },
                        {
                            case: { $gte: [&quot;$totalSpending&quot;, 1000] },
                            then: &quot;Regular&quot;
                        }
                    ],
                    default: &quot;New&quot;
                }
            }
        }
    }
];
</code></pre>
<h3>Redis缓存设计模式</h3>
<pre><code class="language-javascript">// Redis缓存策略实现
class CacheManager {
    constructor(redisClient) {
        this.redis = redisClient;
        this.defaultTTL = 3600; // 1小时
    }

    // 1. Cache-Aside模式
    async getUserProfile(userId) {
        const cacheKey = `user:profile:${userId}`;

        // 先从缓存读取
        const cached = await this.redis.get(cacheKey);
        if (cached) {
            return JSON.parse(cached);
        }

        // 缓存未命中，从数据库读取
        const profile = await this.fetchUserFromDB(userId);
        if (profile) {
            // 写入缓存
            await this.redis.setex(cacheKey, this.defaultTTL, JSON.stringify(profile));
        }

        return profile;
    }

    // 2. Write-Through模式
    async updateUserProfile(userId, profileData) {
        const cacheKey = `user:profile:${userId}`;

        // 同时更新数据库和缓存
        const updatedProfile = await this.updateUserInDB(userId, profileData);
        await this.redis.setex(cacheKey, this.defaultTTL, JSON.stringify(updatedProfile));

        return updatedProfile;
    }

    // 3. Write-Behind模式（异步写入）
    async updateUserProfileAsync(userId, profileData) {
        const cacheKey = `user:profile:${userId}`;
        const queueKey = `write_queue:user:${userId}`;

        // 立即更新缓存
        await this.redis.setex(cacheKey, this.defaultTTL, JSON.stringify(profileData));

        // 将写操作加入队列
        await this.redis.lpush(queueKey, JSON.stringify({
            action: 'update',
            userId,
            data: profileData,
            timestamp: Date.now()
        }));

        return profileData;
    }

    // 4. 分布式锁防止缓存击穿
    async getPopularProduct(productId) {
        const cacheKey = `product:${productId}`;
        const lockKey = `lock:product:${productId}`;

        // 尝试从缓存获取
        const cached = await this.redis.get(cacheKey);
        if (cached) {
            return JSON.parse(cached);
        }

        // 获取分布式锁
        const lockAcquired = await this.redis.set(lockKey, '1', 'PX', 5000, 'NX');

        if (lockAcquired) {
            try {
                // 双重检查
                const cached = await this.redis.get(cacheKey);
                if (cached) {
                    return JSON.parse(cached);
                }

                // 从数据库加载
                const product = await this.fetchProductFromDB(productId);
                if (product) {
                    await this.redis.setex(cacheKey, this.defaultTTL, JSON.stringify(product));
                }

                return product;
            } finally {
                // 释放锁
                await this.redis.del(lockKey);
            }
        } else {
            // 未获得锁，等待一段时间后重试
            await this.sleep(100);
            return this.getPopularProduct(productId);
        }
    }

    // 5. 缓存预热
    async warmUpCache() {
        console.log('Starting cache warm-up...');

        // 预加载热门产品
        const popularProducts = await this.getPopularProductsFromDB();
        for (const product of popularProducts) {
            const cacheKey = `product:${product.id}`;
            await this.redis.setex(cacheKey, this.defaultTTL, JSON.stringify(product));
        }

        // 预加载用户配置
        const activeUsers = await this.getActiveUsersFromDB();
        for (const user of activeUsers) {
            const cacheKey = `user:profile:${user.id}`;
            await this.redis.setex(cacheKey, this.defaultTTL, JSON.stringify(user));
        }

        console.log('Cache warm-up completed');
    }

    // 6. 缓存失效策略
    async invalidateUserCache(userId) {
        const keys = [
            `user:profile:${userId}`,
            `user:preferences:${userId}`,
            `user:orders:${userId}`,
            `user:cart:${userId}`
        ];

        await this.redis.del(...keys);

        // 发布缓存失效事件
        await this.redis.publish('cache:invalidate', JSON.stringify({
            type: 'user',
            userId,
            timestamp: Date.now()
        }));
    }

    // 7. 多级缓存
    async getDataWithMultiLevelCache(key, fetcher, options = {}) {
        const {
            l1TTL = 300,    // L1缓存5分钟
            l2TTL = 3600,   // L2缓存1小时
            useLocalCache = true
        } = options;

        // L1缓存：本地内存缓存
        if (useLocalCache &amp;&amp; this.localCache.has(key)) {
            return this.localCache.get(key);
        }

        // L2缓存：Redis缓存
        const cached = await this.redis.get(key);
        if (cached) {
            const data = JSON.parse(cached);
            if (useLocalCache) {
                this.localCache.set(key, data, l1TTL * 1000);
            }
            return data;
        }

        // 缓存未命中，调用数据获取函数
        const data = await fetcher();
        if (data) {
            // 写入L2缓存
            await this.redis.setex(key, l2TTL, JSON.stringify(data));

            // 写入L1缓存
            if (useLocalCache) {
                this.localCache.set(key, data, l1TTL * 1000);
            }
        }

        return data;
    }

    sleep(ms) {
        return new Promise(resolve =&gt; setTimeout(resolve, ms));
    }
}

// 使用示例
const cacheManager = new CacheManager(redisClient);

// 获取用户资料
const userProfile = await cacheManager.getUserProfile(123);

// 更新用户资料
await cacheManager.updateUserProfile(123, { name: 'John Doe' });

// 缓存预热
await cacheManager.warmUpCache();
</code></pre>
<h2>数据库性能监控</h2>
<h3>性能指标收集</h3>
<pre><code class="language-javascript">// 数据库性能监控工具
class DatabaseMonitor {
    constructor(options = {}) {
        this.connections = options.connections || {};
        this.metrics = new Map();
        this.alertThresholds = {
            queryTime: 1000, // 1秒
            connectionPool: 0.8, // 80%使用率
            cpuUsage: 80, // 80%
            memoryUsage: 85, // 85%
            diskUsage: 90 // 90%
        };
    }

    // MySQL性能监控
    async monitorMySQL() {
        const mysql = this.connections.mysql;

        // 查询性能统计
        const [queryStats] = await mysql.execute(`
            SELECT 
                SCHEMA_NAME as database_name,
                DIGEST_TEXT as query_pattern,
                COUNT_STAR as execution_count,
                AVG_TIMER_WAIT/1000000000 as avg_time_seconds,
                MAX_TIMER_WAIT/1000000000 as max_time_seconds,
                SUM_TIMER_WAIT/1000000000 as total_time_seconds,
                AVG_ROWS_EXAMINED,
                AVG_ROWS_SENT,
                SUM_ROWS_EXAMINED,
                SUM_ERRORS,
                SUM_WARNINGS
            FROM performance_schema.events_statements_summary_by_digest 
            WHERE SCHEMA_NAME IS NOT NULL
            ORDER BY AVG_TIMER_WAIT DESC
            LIMIT 20
        `);

        // 连接池状态
        const [connectionPool] = await mysql.execute(`
            SELECT 
                VARIABLE_NAME,
                VARIABLE_VALUE
            FROM performance_schema.global_status 
            WHERE VARIABLE_NAME IN (
                'Threads_connected',
                'Threads_running',
                'Max_used_connections',
                'Connection_errors_max_connections'
            )
        `);

        // InnoDB状态
        const [innodbStats] = await mysql.execute(`
            SELECT 
                VARIABLE_NAME,
                VARIABLE_VALUE
            FROM performance_schema.global_status 
            WHERE VARIABLE_NAME LIKE 'Innodb_%'
            AND VARIABLE_NAME IN (
                'Innodb_buffer_pool_reads',
                'Innodb_buffer_pool_read_requests',
                'Innodb_rows_read',
                'Innodb_rows_inserted',
                'Innodb_rows_updated',
                'Innodb_rows_deleted'
            )
        `);

        // 表锁等待
        const [lockWaits] = await mysql.execute(`
            SELECT 
                r.trx_id waiting_trx_id,
                r.trx_mysql_thread_id waiting_thread,
                r.trx_query waiting_query,
                b.trx_id blocking_trx_id,
                b.trx_mysql_thread_id blocking_thread,
                b.trx_query blocking_query
            FROM information_schema.innodb_lock_waits w
            INNER JOIN information_schema.innodb_trx b
                ON b.trx_id = w.blocking_trx_id
            INNER JOIN information_schema.innodb_trx r
                ON r.trx_id = w.requesting_trx_id
        `);

        return {
            queryStats,
            connectionPool,
            innodbStats,
            lockWaits,
            timestamp: new Date()
        };
    }

    // MongoDB性能监控
    async monitorMongoDB() {
        const mongo = this.connections.mongodb;

        // 数据库统计
        const dbStats = await mongo.db().stats();

        // 操作统计
        const serverStatus = await mongo.db().admin().serverStatus();

        // 慢查询
        const slowQueries = await mongo.db().admin().aggregate([
            { $currentOp: { allUsers: true, idleConnections: true } },
            { $match: { &quot;microsecs_running&quot;: { $gt: 1000000 } } }, // 超过1秒的查询
            { $project: {
                connectionId: 1,
                opid: 1,
                op: 1,
                ns: 1,
                command: 1,
                planSummary: 1,
                microsecs_running: 1,
                client: 1
            }}
        ]).toArray();

        // 索引使用统计
        const collections = await mongo.db().listCollections().toArray();
        const indexStats = [];

        for (const collection of collections) {
            const stats = await mongo.db().collection(collection.name).aggregate([
                { $indexStats: {} }
            ]).toArray();
            indexStats.push({
                collection: collection.name,
                indexes: stats
            });
        }

        return {
            dbStats,
            serverStatus: {
                opcounters: serverStatus.opcounters,
                connections: serverStatus.connections,
                network: serverStatus.network,
                mem: serverStatus.mem,
                metrics: serverStatus.metrics
            },
            slowQueries,
            indexStats,
            timestamp: new Date()
        };
    }

    // Redis性能监控
    async monitorRedis() {
        const redis = this.connections.redis;

        // 基础信息
        const info = await redis.info();
        const infoObj = this.parseRedisInfo(info);

        // 慢查询日志
        const slowlog = await redis.slowlog('get', 10);

        // 内存使用分析
        const memoryUsage = await redis.memory('usage', 'key-pattern', '*');

        // 客户端连接信息
        const clients = await redis.client('list');

        // 命令统计
        const commandStats = infoObj.commandstats || {};

        return {
            info: infoObj,
            slowlog,
            memoryUsage,
            clients: this.parseRedisClients(clients),
            commandStats,
            timestamp: new Date()
        };
    }

    // 性能告警
    async checkAlerts(metrics) {
        const alerts = [];

        // MySQL告警检查
        if (metrics.mysql) {
            const mysql = metrics.mysql;

            // 慢查询告警
            mysql.queryStats.forEach(query =&gt; {
                if (query.avg_time_seconds &gt; this.alertThresholds.queryTime / 1000) {
                    alerts.push({
                        type: 'slow_query',
                        database: 'mysql',
                        severity: 'warning',
                        message: `Slow query detected: ${query.avg_time_seconds.toFixed(2)}s average`,
                        details: query
                    });
                }
            });

            // 锁等待告警
            if (mysql.lockWaits.length &gt; 0) {
                alerts.push({
                    type: 'lock_wait',
                    database: 'mysql',
                    severity: 'critical',
                    message: `${mysql.lockWaits.length} lock waits detected`,
                    details: mysql.lockWaits
                });
            }
        }

        // MongoDB告警检查
        if (metrics.mongodb) {
            const mongo = metrics.mongodb;

            // 慢查询告警
            if (mongo.slowQueries.length &gt; 0) {
                alerts.push({
                    type: 'slow_query',
                    database: 'mongodb',
                    severity: 'warning',
                    message: `${mongo.slowQueries.length} slow queries detected`,
                    details: mongo.slowQueries
                });
            }

            // 连接数告警
            const connectionUsage = mongo.serverStatus.connections.current / 
                                   mongo.serverStatus.connections.available;
            if (connectionUsage &gt; this.alertThresholds.connectionPool) {
                alerts.push({
                    type: 'high_connections',
                    database: 'mongodb',
                    severity: 'warning',
                    message: `High connection usage: ${(connectionUsage * 100).toFixed(1)}%`,
                    details: mongo.serverStatus.connections
                });
            }
        }

        // Redis告警检查
        if (metrics.redis) {
            const redis = metrics.redis;

            // 内存使用告警
            const memoryUsage = redis.info.memory.used_memory / redis.info.memory.maxmemory;
            if (memoryUsage &gt; this.alertThresholds.memoryUsage / 100) {
                alerts.push({
                    type: 'high_memory',
                    database: 'redis',
                    severity: 'critical',
                    message: `High memory usage: ${(memoryUsage * 100).toFixed(1)}%`,
                    details: redis.info.memory
                });
            }
        }

        return alerts;
    }

    // 生成性能报告
    generateReport(metrics, alerts) {
        const report = {
            timestamp: new Date(),
            summary: {
                totalAlerts: alerts.length,
                criticalAlerts: alerts.filter(a =&gt; a.severity === 'critical').length,
                warningAlerts: alerts.filter(a =&gt; a.severity === 'warning').length
            },
            databases: {},
            alerts,
            recommendations: []
        };

        // MySQL报告
        if (metrics.mysql) {
            const mysql = metrics.mysql;
            report.databases.mysql = {
                slowQueries: mysql.queryStats.filter(q =&gt; q.avg_time_seconds &gt; 1).length,
                avgQueryTime: mysql.queryStats.reduce((sum, q) =&gt; sum + q.avg_time_seconds, 0) / mysql.queryStats.length,
                totalConnections: mysql.connectionPool.find(c =&gt; c.VARIABLE_NAME === 'Threads_connected')?.VARIABLE_VALUE || 0,
                lockWaits: mysql.lockWaits.length
            };

            // MySQL优化建议
            if (mysql.queryStats.some(q =&gt; q.avg_time_seconds &gt; 2)) {
                report.recommendations.push({
                    database: 'mysql',
                    type: 'query_optimization',
                    message: 'Consider optimizing slow queries with proper indexing'
                });
            }
        }

        // MongoDB报告
        if (metrics.mongodb) {
            const mongo = metrics.mongodb;
            report.databases.mongodb = {
                slowQueries: mongo.slowQueries.length,
                connections: mongo.serverStatus.connections.current,
                memoryUsage: `${(mongo.serverStatus.mem.resident / 1024).toFixed(2)}GB`,
                operations: mongo.serverStatus.opcounters
            };

            // 索引使用建议
            const unusedIndexes = mongo.indexStats.filter(idx =&gt; 
                idx.indexes.some(i =&gt; i.accesses.ops === 0)
            );
            if (unusedIndexes.length &gt; 0) {
                report.recommendations.push({
                    database: 'mongodb',
                    type: 'index_optimization',
                    message: 'Remove unused indexes to improve write performance'
                });
            }
        }

        return report;
    }

    parseRedisInfo(info) {
        const sections = {};
        let currentSection = null;

        info.split('\r\n').forEach(line =&gt; {
            if (line.startsWith('#')) {
                currentSection = line.substring(2).toLowerCase();
                sections[currentSection] = {};
            } else if (line.includes(':') &amp;&amp; currentSection) {
                const [key, value] = line.split(':');
                sections[currentSection][key] = isNaN(value) ? value : Number(value);
            }
        });

        return sections;
    }

    parseRedisClients(clientsStr) {
        return clientsStr.split('\n').filter(line =&gt; line.trim()).map(line =&gt; {
            const parts = line.split(' ');
            const client = {};
            parts.forEach(part =&gt; {
                const [key, value] = part.split('=');
                if (key &amp;&amp; value) {
                    client[key] = value;
                }
            });
            return client;
        });
    }
}

// 使用示例
const monitor = new DatabaseMonitor({
    connections: {
        mysql: mysqlConnection,
        mongodb: mongoConnection,
        redis: redisConnection
    }
});

// 定期监控
setInterval(async () =&gt; {
    try {
        const metrics = {
            mysql: await monitor.monitorMySQL(),
            mongodb: await monitor.monitorMongoDB(),
            redis: await monitor.monitorRedis()
        };

        const alerts = await monitor.checkAlerts(metrics);
        const report = monitor.generateReport(metrics, alerts);

        console.log('Database Performance Report:', report);

        // 如果有严重告警，发送通知
        if (alerts.some(a =&gt; a.severity === 'critical')) {
            await this.sendAlert(alerts);
        }

    } catch (error) {
        console.error('Monitoring error:', error);
    }
}, 60000); // 每分钟检查一次
</code></pre>
<h2>总结与最佳实践</h2>
<h3>数据库选择指南</h3>
<pre><code class="language-javascript">const databaseSelectionGuide = {
    关系型数据库: {
        适用场景: [
            &quot;ACID事务要求强&quot;,
            &quot;复杂的关联查询&quot;,
            &quot;数据一致性要求高&quot;,
            &quot;传统业务系统&quot;
        ],
        推荐: [&quot;PostgreSQL&quot;, &quot;MySQL&quot;, &quot;SQL Server&quot;],
        优化重点: [&quot;索引设计&quot;, &quot;查询优化&quot;, &quot;分区表&quot;, &quot;读写分离&quot;]
    },

    文档数据库: {
        适用场景: [
            &quot;半结构化数据&quot;,
            &quot;快速迭代开发&quot;,
            &quot;水平扩展需求&quot;,
            &quot;内容管理系统&quot;
        ],
        推荐: [&quot;MongoDB&quot;, &quot;CouchDB&quot;],
        优化重点: [&quot;文档结构设计&quot;, &quot;索引策略&quot;, &quot;分片配置&quot;, &quot;聚合管道&quot;]
    },

    键值存储: {
        适用场景: [
            &quot;缓存系统&quot;,
            &quot;会话存储&quot;,
            &quot;实时数据&quot;,
            &quot;高并发读写&quot;
        ],
        推荐: [&quot;Redis&quot;, &quot;Amazon DynamoDB&quot;],
        优化重点: [&quot;内存管理&quot;, &quot;持久化策略&quot;, &quot;集群配置&quot;, &quot;数据结构选择&quot;]
    },

    列族数据库: {
        适用场景: [
            &quot;大数据分析&quot;,
            &quot;时间序列数据&quot;,
            &quot;日志存储&quot;,
            &quot;IoT数据&quot;
        ],
        推荐: [&quot;Cassandra&quot;, &quot;HBase&quot;],
        优化重点: [&quot;分区键设计&quot;, &quot;压缩策略&quot;, &quot;读写路径优化&quot;]
    },

    图数据库: {
        适用场景: [
            &quot;社交网络&quot;,
            &quot;推荐系统&quot;,
            &quot;欺诈检测&quot;,
            &quot;知识图谱&quot;
        ],
        推荐: [&quot;Neo4j&quot;, &quot;Amazon Neptune&quot;],
        优化重点: [&quot;图模型设计&quot;, &quot;查询语言优化&quot;, &quot;索引策略&quot;]
    }
};
</code></pre>
<h3>性能优化检查清单</h3>
<ol>
<li><strong>设计阶段</strong></li>
<li>选择合适的数据库类型</li>
<li>正确的数据建模</li>
<li>合理的范式化程度</li>
<li>
<p>预估数据量和并发量</p>
</li>
<li>
<p><strong>开发阶段</strong></p>
</li>
<li>设计有效的索引策略</li>
<li>避免N+1查询问题</li>
<li>使用预编译语句</li>
<li>
<p>实现合适的缓存策略</p>
</li>
<li>
<p><strong>部署阶段</strong></p>
</li>
<li>配置合理的连接池</li>
<li>设置适当的缓冲区大小</li>
<li>配置监控和告警</li>
<li>
<p>建立备份和恢复策略</p>
</li>
<li>
<p><strong>运维阶段</strong></p>
</li>
<li>定期性能分析</li>
<li>索引维护和优化</li>
<li>容量规划</li>
<li>故障排查和调优</li>
</ol>
<p>通过这次数据库设计模式和性能优化的深入实践，我对不同数据库的特点和适用场景有了更清晰的认识。在实际项目中，选择合适的数据库技术栈，配合正确的设计模式和优化策略，能够显著提升应用的性能和可扩展性。</p>
<p>数据库技术发展迅速，我们需要持续学习新的技术和最佳实践，同时也要深入理解基础原理，这样才能在面对各种复杂场景时做出正确的技术选择。</p>
                </div>
            </article>
        </div>
    </main>
    
    <footer>
        <p>&copy; 2025 我的博客. All rights reserved.</p>
    </footer>
</body>
</html>