<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>工作日志：解决线上MySQL死锁问题的完整过程 - 我的博客</title>
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <header>
        <h1 class="slogan">记录思考，分享生活</h1>
    </header>
    
    <main>
        <div class="container">
            <a href="../index.html" class="back-link">← 返回首页</a>
            
            <article class="article-page">
                <div class="article-header">
                    <h1>工作日志：解决线上MySQL死锁问题的完整过程</h1>
                    <p class="article-date">2025年07月03日</p>
                </div>
                
                <div class="article-content">
                    <p><strong>Date: April 12, 2024</strong></p>
<p>今天遇到了一个比较棘手的MySQL死锁问题，花了大半天时间才彻底解决。记录一下整个排查和解决的过程，希望能对遇到类似问题的同学有所帮助。</p>
<h2>问题发现</h2>
<p>早上9点左右，监控系统开始报警，显示数据库连接池耗尽，应用响应时间急剧上升。通过日志发现大量的死锁错误：</p>
<pre><code>2024-04-12 09:15:32 [ERROR] Deadlock found when trying to get lock; try restarting transaction
</code></pre>
<h2>初步排查</h2>
<h3>1. 查看当前运行的事务</h3>
<pre><code class="language-sql">-- 查看当前正在执行的事务
SELECT 
    trx_id,
    trx_state,
    trx_started,
    trx_requested_lock_id,
    trx_wait_started,
    trx_weight,
    trx_mysql_thread_id,
    trx_query
FROM information_schema.INNODB_TRX;
</code></pre>
<p>发现有多个长时间运行的事务，状态都是LOCK WAIT。</p>
<h3>2. 检查锁等待情况</h3>
<pre><code class="language-sql">-- 查看锁等待情况
SELECT 
    r.trx_id waiting_trx_id,
    r.trx_mysql_thread_id waiting_thread,
    r.trx_query waiting_query,
    b.trx_id blocking_trx_id,
    b.trx_mysql_thread_id blocking_thread,
    b.trx_query blocking_query
FROM information_schema.INNODB_LOCK_WAITS w
INNER JOIN information_schema.INNODB_TRX b ON b.trx_id = w.blocking_trx_id
INNER JOIN information_schema.INNODB_TRX r ON r.trx_id = w.requesting_trx_id;
</code></pre>
<h3>3. 启用死锁检测日志</h3>
<pre><code class="language-sql">-- 查看最近的死锁信息
SHOW ENGINE INNODB STATUS\G
</code></pre>
<p>从输出中找到了死锁的详细信息：</p>
<pre><code>------------------------
LATEST DETECTED DEADLOCK
------------------------
2024-04-12 09:15:32 0x7f8b1c0e9700
*** (1) TRANSACTION:
TRANSACTION 421394382869, ACTIVE 2 sec starting index read
mysql tables in use 2, locked 2
LOCK WAIT 3 lock struct(s), heap size 1136, 2 row lock(s)
MySQL thread id 2, OS thread handle 140239954323200, query id 1234567 localhost root updating
UPDATE orders SET status = 'processing' WHERE id = 12345

*** (1) WAITING FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 58 page no 4 n bits 72 index PRIMARY of table `ecommerce`.`orders` 
trx id 421394382869 lock_mode X locks rec but not gap waiting

*** (2) TRANSACTION:
TRANSACTION 421394382870, ACTIVE 1 sec starting index read
mysql tables in use 2, locked 2
LOCK WAIT 4 lock struct(s), heap size 1136, 3 row lock(s)
MySQL thread id 3, OS thread handle 140239954323200, query id 1234568 localhost root updating
UPDATE inventory SET quantity = quantity - 1 WHERE product_id = 67890

*** (2) HOLDS THE LOCK(S):
RECORD LOCKS space id 58 page no 4 n bits 72 index PRIMARY of table `ecommerce`.`orders`
trx id 421394382870 lock_mode X locks rec but not gap

*** (2) WAITING FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 59 page no 5 n bits 72 index idx_product_id of table `ecommerce`.`inventory`
trx id 421394382870 lock_mode X locks rec but not gap waiting

*** WE ROLL BACK TRANSACTION (1)
</code></pre>
<h2>问题分析</h2>
<p>通过分析死锁日志和业务代码，发现问题出现在订单处理的逻辑中：</p>
<h3>死锁场景重现</h3>
<pre><code class="language-javascript">// 订单处理服务中的问题代码
class OrderService {
  async processOrder(orderId, items) {
    const connection = await db.getConnection();

    try {
      await connection.beginTransaction();

      // 事务A：更新订单状态
      await connection.query(
        'UPDATE orders SET status = ? WHERE id = ?',
        ['processing', orderId]
      );

      // 然后更新库存
      for (const item of items) {
        await connection.query(
          'UPDATE inventory SET quantity = quantity - ? WHERE product_id = ?',
          [item.quantity, item.productId]
        );
      }

      await connection.commit();
    } catch (error) {
      await connection.rollback();
      throw error;
    } finally {
      connection.release();
    }
  }

  async cancelOrder(orderId, items) {
    const connection = await db.getConnection();

    try {
      await connection.beginTransaction();

      // 事务B：先恢复库存
      for (const item of items) {
        await connection.query(
          'UPDATE inventory SET quantity = quantity + ? WHERE product_id = ?',
          [item.quantity, item.productId]
        );
      }

      // 然后更新订单状态
      await connection.query(
        'UPDATE orders SET status = ? WHERE id = ?',
        ['cancelled', orderId]
      );

      await connection.commit();
    } catch (error) {
      await connection.rollback();
      throw error;
    } finally {
      connection.release();
    }
  }
}
</code></pre>
<p><strong>死锁原因分析：</strong><br />
1. 事务A：先锁定orders表，再锁定inventory表<br />
2. 事务B：先锁定inventory表，再锁定orders表<br />
3. 当两个事务同时执行时，形成了循环等待，导致死锁</p>
<h2>解决方案</h2>
<h3>1. 统一锁顺序</h3>
<p>最直接的解决方案是确保所有事务按相同的顺序获取锁：</p>
<pre><code class="language-javascript">class OrderService {
  async processOrder(orderId, items) {
    const connection = await db.getConnection();

    try {
      await connection.beginTransaction();

      // 统一顺序：先处理inventory，再处理orders
      // 按product_id排序确保一致的锁顺序
      const sortedItems = items.sort((a, b) =&gt; a.productId - b.productId);

      for (const item of sortedItems) {
        await connection.query(
          'UPDATE inventory SET quantity = quantity - ? WHERE product_id = ? AND quantity &gt;= ?',
          [item.quantity, item.productId, item.quantity]
        );
      }

      await connection.query(
        'UPDATE orders SET status = ? WHERE id = ?',
        ['processing', orderId]
      );

      await connection.commit();
    } catch (error) {
      await connection.rollback();
      throw error;
    } finally {
      connection.release();
    }
  }

  async cancelOrder(orderId, items) {
    const connection = await db.getConnection();

    try {
      await connection.beginTransaction();

      // 保持相同的锁顺序：先inventory，再orders
      const sortedItems = items.sort((a, b) =&gt; a.productId - b.productId);

      for (const item of sortedItems) {
        await connection.query(
          'UPDATE inventory SET quantity = quantity + ? WHERE product_id = ?',
          [item.quantity, item.productId]
        );
      }

      await connection.query(
        'UPDATE orders SET status = ? WHERE id = ?',
        ['cancelled', orderId]
      );

      await connection.commit();
    } catch (error) {
      await connection.rollback();
      throw error;
    } finally {
      connection.release();
    }
  }
}
</code></pre>
<h3>2. 减少事务持有锁的时间</h3>
<pre><code class="language-javascript">// 拆分大事务为小事务
class OptimizedOrderService {
  async processOrder(orderId, items) {
    // 1. 先检查库存是否充足
    const inventoryCheck = await this.checkInventory(items);
    if (!inventoryCheck.sufficient) {
      throw new Error('Insufficient inventory');
    }

    // 2. 使用更细粒度的锁
    await this.updateInventoryWithRetry(items);

    // 3. 更新订单状态
    await this.updateOrderStatus(orderId, 'processing');
  }

  async updateInventoryWithRetry(items, maxRetries = 3) {
    for (let attempt = 1; attempt &lt;= maxRetries; attempt++) {
      try {
        const connection = await db.getConnection();

        try {
          await connection.beginTransaction();

          // 使用SELECT ... FOR UPDATE预先获取锁
          const lockQuery = `
            SELECT product_id, quantity 
            FROM inventory 
            WHERE product_id IN (${items.map(() =&gt; '?').join(',')})
            FOR UPDATE
          `;

          await connection.query(lockQuery, items.map(item =&gt; item.productId));

          // 批量更新库存
          for (const item of items) {
            const result = await connection.query(
              'UPDATE inventory SET quantity = quantity - ? WHERE product_id = ? AND quantity &gt;= ?',
              [item.quantity, item.productId, item.quantity]
            );

            if (result.affectedRows === 0) {
              throw new Error(`Insufficient inventory for product ${item.productId}`);
            }
          }

          await connection.commit();
          return; // 成功，退出重试循环

        } catch (error) {
          await connection.rollback();
          throw error;
        } finally {
          connection.release();
        }

      } catch (error) {
        if (error.code === 'ER_LOCK_DEADLOCK' &amp;&amp; attempt &lt; maxRetries) {
          // 死锁，等待随机时间后重试
          const delay = Math.random() * 100 + 50; // 50-150ms
          await new Promise(resolve =&gt; setTimeout(resolve, delay));
          continue;
        }
        throw error;
      }
    }
  }

  async updateOrderStatus(orderId, status) {
    const connection = await db.getConnection();

    try {
      await connection.query(
        'UPDATE orders SET status = ?, updated_at = NOW() WHERE id = ?',
        [status, orderId]
      );
    } finally {
      connection.release();
    }
  }
}
</code></pre>
<h3>3. 添加死锁重试机制</h3>
<pre><code class="language-javascript">// 通用的死锁重试装饰器
function withDeadlockRetry(maxRetries = 3) {
  return function(target, propertyName, descriptor) {
    const method = descriptor.value;

    descriptor.value = async function(...args) {
      for (let attempt = 1; attempt &lt;= maxRetries; attempt++) {
        try {
          return await method.apply(this, args);
        } catch (error) {
          if (error.code === 'ER_LOCK_DEADLOCK' &amp;&amp; attempt &lt; maxRetries) {
            console.log(`Deadlock detected, retrying (${attempt}/${maxRetries})...`);

            // 指数退避 + 随机jitter
            const baseDelay = Math.pow(2, attempt - 1) * 100;
            const jitter = Math.random() * 50;
            const delay = baseDelay + jitter;

            await new Promise(resolve =&gt; setTimeout(resolve, delay));
            continue;
          }
          throw error;
        }
      }
    };

    return descriptor;
  };
}

// 使用装饰器
class OrderService {
  @withDeadlockRetry(3)
  async processOrder(orderId, items) {
    // 原有的业务逻辑
  }

  @withDeadlockRetry(3)
  async cancelOrder(orderId, items) {
    // 原有的业务逻辑
  }
}
</code></pre>
<h2>数据库层面的优化</h2>
<h3>1. 调整MySQL配置</h3>
<pre><code class="language-sql">-- 调整死锁检测相关参数
SET GLOBAL innodb_deadlock_detect = ON;
SET GLOBAL innodb_lock_wait_timeout = 10;
SET GLOBAL innodb_rollback_on_timeout = ON;

-- 优化事务隔离级别
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
</code></pre>
<h3>2. 添加合适的索引</h3>
<pre><code class="language-sql">-- 为经常一起查询的字段添加复合索引
ALTER TABLE orders ADD INDEX idx_status_created (status, created_at);
ALTER TABLE inventory ADD INDEX idx_product_quantity (product_id, quantity);

-- 确保外键字段有索引
ALTER TABLE order_items ADD INDEX idx_order_id (order_id);
ALTER TABLE order_items ADD INDEX idx_product_id (product_id);
</code></pre>
<h3>3. 监控和告警</h3>
<pre><code class="language-javascript">// 添加死锁监控
class DeadlockMonitor {
  constructor() {
    this.deadlockCount = 0;
    this.alertThreshold = 10; // 10分钟内超过10次死锁就告警
    this.timeWindow = 10 * 60 * 1000; // 10分钟
    this.recentDeadlocks = [];
  }

  recordDeadlock() {
    const now = Date.now();
    this.recentDeadlocks.push(now);

    // 清理过期记录
    this.recentDeadlocks = this.recentDeadlocks.filter(
      timestamp =&gt; now - timestamp &lt; this.timeWindow
    );

    // 检查是否需要告警
    if (this.recentDeadlocks.length &gt;= this.alertThreshold) {
      this.sendAlert();
    }
  }

  async sendAlert() {
    const message = `Deadlock alert: ${this.recentDeadlocks.length} deadlocks in the last 10 minutes`;

    // 发送告警到监控系统
    await this.sendToMonitoringSystem({
      level: 'warning',
      message: message,
      timestamp: new Date().toISOString()
    });
  }

  async sendToMonitoringSystem(alert) {
    // 实现告警发送逻辑
    console.log('Alert sent:', alert);
  }
}

// 在数据库错误处理中使用
const deadlockMonitor = new DeadlockMonitor();

function handleDatabaseError(error) {
  if (error.code === 'ER_LOCK_DEADLOCK') {
    deadlockMonitor.recordDeadlock();
  }

  // 其他错误处理逻辑
}
</code></pre>
<h2>验证和测试</h2>
<h3>1. 压力测试</h3>
<pre><code class="language-javascript">// 死锁测试脚本
class DeadlockStressTest {
  async runTest(concurrency = 10, duration = 60000) {
    console.log(`Starting deadlock stress test: ${concurrency} concurrent users for ${duration}ms`);

    const startTime = Date.now();
    const workers = [];

    for (let i = 0; i &lt; concurrency; i++) {
      workers.push(this.workerTask(i, startTime, duration));
    }

    const results = await Promise.allSettled(workers);

    // 统计结果
    const summary = this.summarizeResults(results);
    console.log('Test completed:', summary);

    return summary;
  }

  async workerTask(workerId, startTime, duration) {
    const stats = {
      workerId,
      operations: 0,
      deadlocks: 0,
      errors: 0
    };

    while (Date.now() - startTime &lt; duration) {
      try {
        // 随机选择操作类型
        const operation = Math.random() &gt; 0.5 ? 'process' : 'cancel';
        const orderId = Math.floor(Math.random() * 1000) + 1;
        const items = this.generateRandomItems();

        if (operation === 'process') {
          await this.orderService.processOrder(orderId, items);
        } else {
          await this.orderService.cancelOrder(orderId, items);
        }

        stats.operations++;

      } catch (error) {
        if (error.code === 'ER_LOCK_DEADLOCK') {
          stats.deadlocks++;
        } else {
          stats.errors++;
        }
      }

      // 随机延迟
      await new Promise(resolve =&gt; setTimeout(resolve, Math.random() * 100));
    }

    return stats;
  }

  generateRandomItems() {
    const itemCount = Math.floor(Math.random() * 3) + 1;
    const items = [];

    for (let i = 0; i &lt; itemCount; i++) {
      items.push({
        productId: Math.floor(Math.random() * 100) + 1,
        quantity: Math.floor(Math.random() * 5) + 1
      });
    }

    return items;
  }
}
</code></pre>
<h2>最终效果</h2>
<p>经过以上优化后，线上环境的死锁问题得到了显著改善：</p>
<ul>
<li><strong>死锁频率</strong>：从每小时20-30次降低到每天1-2次</li>
<li><strong>平均响应时间</strong>：从2-3秒降低到200-300ms</li>
<li><strong>数据库连接池利用率</strong>：从90%以上降低到30-40%</li>
<li><strong>系统稳定性</strong>：24小时内零故障</li>
</ul>
<h2>总结和反思</h2>
<h3>经验教训</h3>
<ol>
<li><strong>预防大于治疗</strong>：在设计阶段就要考虑并发控制</li>
<li><strong>监控很重要</strong>：完善的监控能帮助快速定位问题</li>
<li><strong>测试要充分</strong>：压力测试能提前发现并发问题</li>
<li><strong>文档要完善</strong>：记录问题解决过程，避免重复踩坑</li>
</ol>
<h3>后续优化计划</h3>
<ol>
<li><strong>引入分布式锁</strong>：考虑使用Redis等外部存储实现分布式锁</li>
<li><strong>数据库分片</strong>：将热点数据分散到多个数据库实例</li>
<li><strong>异步处理</strong>：将部分操作改为异步处理，减少事务持有时间</li>
<li><strong>读写分离</strong>：将查询操作分流到只读实例</li>
</ol>
<p>这次死锁问题的解决过程让我对MySQL的锁机制有了更深入的理解，也积累了宝贵的线上问题处理经验。记录下来希望能帮助到其他同学，同时也提醒自己在后续的开发中要更加注意并发安全问题。</p>
                </div>
            </article>
        </div>
    </main>
    
    <footer>
        <p>&copy; 2025 我的博客. All rights reserved.</p>
    </footer>
</body>
</html>